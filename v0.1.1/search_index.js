var documenterSearchIndex = {"docs":
[{"location":"build_tips/#构建提示","page":"构建提示","title":"构建提示","text":"","category":"section"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"BinaryBuilder 提供了一个方便的环境来实现跨平台构建。但是许多库都有复杂的构建脚本，可能需要进行调整以支持所有 BinaryBuilder 目标。","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"如果您的构建因某些错误而失败，请查看 构建故障排除 页面。","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"如果您有其他点子，请提交带建议的 PR。","category":"page"},{"location":"build_tips/#根据目标发起不同的-shell-命令","page":"构建提示","title":"根据目标发起不同的 shell 命令","text":"","category":"section"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"有时，您需要根据目标平台调整构建脚本。这可以在 shell 脚本中完成。这是来自 OpenBLAS 的示例：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"# Set BINARY=32 on i686 platforms and armv7l\nif [[ ${nbits} == 32 ]]; then\n    flags=\"${flags} BINARY=32\"\nfi","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"以下是具有特定目标检查的脚本的其他示例：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"Kaleido - Windows 和 macOS 的不同步骤","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"Libical - 32 位检查","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"通过为不同的目标集运行不同的构建脚本，也可以为每个目标运行完全不同的脚本。以下是 Windows 构建与其他目标分离的示例：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"Git","category":"page"},{"location":"build_tips/#自动配置构建","page":"构建提示","title":"自动配置构建","text":"","category":"section"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"自动配置构建通常非常简单，下边是一个典型的方法：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"./configure --prefix=$prefix --build=${MACHTYPE} --host=${target}\nmake -j${nproc}\nmake install","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"以下是自动配置构建脚本的示例：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"Patchelf\nLibCURL","category":"page"},{"location":"build_tips/#CMake-构建","page":"构建提示","title":"CMake 构建","text":"","category":"section"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"对于 CMake，向导将建议一个用于运行 CMake 的模板。典例如下：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"cmake -DCMAKE_INSTALL_PREFIX=${prefix} -DCMAKE_TOOLCHAIN_FILE=${CMAKE_TARGET_TOOLCHAIN} -DCMAKE_BUILD_TYPE=Release","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"工具链文件设置了几个 CMake 环境变量以提供更好的跨平台支持，例如 CMAKE_SYSROOT、CMAKE_C_COMPILER 等。包含 CMake 部分的构建示例包括：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"JpegTurbo\nSundials\n对于 Windows 系统，需要将 *.dll 文件从 ${prefix}/lib 复制到 ${libdir}\n需要 KLU_LIBRARY_DIR=\"$libdir\" 以便 CMake 的 find_library 可以从 KLU 中找到库","category":"page"},{"location":"build_tips/#Meson-构建","page":"构建提示","title":"Meson 构建","text":"","category":"section"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"BinaryBuilder 还支持使用 Meson 进行构建。因为这将是一个交叉编译，你必须指定一个 Meson 交叉文件：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"meson --cross-file=\"${MESON_TARGET_TOOLCHAIN}\" --buildtype=release","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"使用 meson 配置项目后，您可以使用","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"ninja -j${nproc}\nninja install","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"如果 meson.build 文件存在，向导会自动建议使用 Meson。","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"使用 Meson 执行的构建示例包括：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"gdk-pixbuf:\nmeson 在这里使用依赖于平台的选项；\nlibepoxy:\n该脚本修改 Meson 交叉文件中的 c_args 以添加包含目录；\nxkbcommon.","category":"page"},{"location":"build_tips/#Go-构建","page":"构建提示","title":"Go 构建","text":"","category":"section"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"可以通过将 :go 添加到 build_tarballs 的 compilers 关键字参数来请求 BinaryBuilder 提供的 Go 工具链：compilers=[:c, :go]。基于 Go 的包通常可以使用 go 构建和安装：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"go build -o ${bindir}","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"BinaryBuilder 提供的 Go 工具链会自动选择合适的目标。","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"使用 Go 的包示例：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"pprof：它使用 go build 编译程序并手动移动可执行文件到 ${bindir}。","category":"page"},{"location":"build_tips/#Rust-构建","page":"构建提示","title":"Rust 构建","text":"","category":"section"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"可以通过将 :rust 添加到 build_tarballs 的 compilers 关键字参数来请求 BinaryBuilder 提供的 Rust 工具链：compilers=[:c, :rust]。基于 Rust 的包通常可以用 cargo 构建：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"cargo build --release","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"BinaryBuilder 提供的 Rust 工具链会自动选择合适的目标和要使用的并行作业数。但是请注意，您可能必须在 ${prefix} 中手动安装该产品。阅读包的安装说明，以防他们推荐不同的构建过程。","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"使用 Rust 的包示例：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"Tokei：它使用 cargo build 编译程序并手动移动可执行文件到${bindir};\nLibrsvg：它使用基于 Autoconf 的构建系统，该系统将在内部调用“cargo build” , 但用户必须遵循 ./configure + make + make install 顺序。","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"warning: Warning\n当前使用的 Rust 工具链不适用于 i686-w64-mingw32（32 位 Windows）平台。","category":"page"},{"location":"build_tips/#在向导中编辑文件","page":"构建提示","title":"在向导中编辑文件","text":"","category":"section"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"在向导中，vim 编辑器可用于编辑文件。但是，它不会在构建脚本中留下任何记录。通常需要提供补丁文件或使用类似 sed 的东西。如果文件需要修补，我们建议使用 git 将整个工作树添加到新的存储库中，进行所需的更改，然后使用 git diff -p 输出一个补丁，该补丁可以包含在您的构建配方中。","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"你可以很容易地包含像补丁这样的本地文件，方法是将它们放在 bundled/patches 嵌套目录中，然后提供 ./bundled 作为构建的 sources 之一。作为例子，参见 OpenBLAS。","category":"page"},{"location":"build_tips/#自动环境变量","page":"构建提示","title":"自动环境变量","text":"","category":"section"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"以下环境变量在构建环境中自动设置，应该用于构建项目。有时，您可能需要调整它们（例如，在 macOS 和 FreeBSD 上使用 GCC）。","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"CC: C 交叉编译器\nCXX: C++ 交叉编译器\nFC: Fortran 交叉编译器","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"上述变量指向目标环境的实用程序。要引用主机环境的实用程序，请在前面加上 HOST 或附加 _HOST。例如，HOSTCC 和 CC_HOST 指向本机 C 编译器。","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"这些是您可能偶尔需要在构建过程中设置的其他环境变量","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"CFLAGS: C 编译器的选项\nCXXFLAGS：C++ 编译器的选项\nCPPFLAGS: C 预处理器的选项\nLDFLAGS：链接器的选项\nPKG_CONFIG_PATH：以冒号分隔的目录列表，用于搜索 .pc 文件\nPKG_CONFIG_SYSROOT_DIR：修改 -I 和 -L 以使用位于目标 sysroot 中的目录","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"以下变量可用于控制不同目标系统上的构建脚本，但不应由用户修改：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"prefix：所有产品应该安装的顶级目录的路径。这将是生成的压缩包的顶级目录\nlibdir：应该安装共享库的目录路径。这是为 Windows 构建时的 ${prefix}/bin，对于所有其他平台为 ${prefix}/lib\nbindir：可执行文件安装目录的路径。这相当于 ${prefix}/bin\nincludedir：头文件安装目录的路径。这相当于 ${prefix}/include\n具有类似含义的类似变量存在于 host 前缀（其中安装了 HostBuildDependency）：${host_prefix}、${host_bindir}、${host_libdir}、${host_includedir}\ntarget: 目标平台\nbb_full_target：完整的目标平台，包含诸如 libstdc++ 字符串 ABI 平台标签和 libgfortran 版本之类的东西\nMACHTYPE：主机平台的三元组\nnproc：主机的处理器数量，对并行构建很有用（例如，make -j${nproc}）\nnbits：目标架构的位数（通常为 32 或 64）\nproc_family：目标处理器系列（例如，“intel”、“power”或“arm”）\ndlext：目标系统上共享库的扩展。 Windows 为“dll”，macOS 为“dylib”，其他 Unix 系统为“so”\nexeext：目标系统上可执行文件的扩展名，拓展名需加上 .。对于 Windows 为“.exe”，对于所有其他目标平台为空字符串“”\nSRC_NAME: 正在构建的项目名称","category":"page"},{"location":"build_tips/#在-macOS-和-FreeBSD-上使用-GCC","page":"构建提示","title":"在 macOS 和 FreeBSD 上使用 GCC","text":"","category":"section"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"对于这些目标系统，Clang 是默认编译器，但是某些程序可能与 Clang 不兼容。","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"对于使用 CMake 构建的程序（请参阅 CMake build 部分），您可以使用位于 ${CMAKE_TARGET_TOOLCHAIN%.*}_gcc.cmake 中的 GCC 工具链文件。","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"如果您要构建的项目使用 GNU 构建系统（也称为 Autotools），则不会自动切换为使用 GCC，但您必须设置适当的变量。例如，此设置可用于使用适用于 FreeBSD 和 macOS 的 GCC 构建大多数 C/C++ 程序：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"if [[ \"${target}\" == *-freebsd* ]] || [[ \"${target}\" == *-apple-* ]]; then\n    CC=gcc\n    CXX=g++\nfi","category":"page"},{"location":"build_tips/#目标系统与主机系统的依赖关系","page":"构建提示","title":"目标系统与主机系统的依赖关系","text":"","category":"section"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"译注：这节与构建提示的 二进制依赖 一节相关。","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"BinaryBuilder 提供了一个交叉编译环境，这意味着通常目标平台（构建二进制文件最终将运行的地方）和主机平台（当前正在进行编译的地方）之间存在区别。特别是，在一般的构建环境中，您不能运行为目标平台构建的二进制可执行文件。","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"要使构建正常工作，可能存在不同类型的依赖关系，例如：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"当前构建的最终产品（二进制可执行文件或其他库）需要链接到的二进制库。这些库必须是为目标平台构建的。您可以将此类依赖项安装为 Dependency，这也将是生成的 JLL 包的依赖项。这是最常见的依赖类；\n二进制库或非二进制可执行文件（通常是实际上可以在构建环境中运行的 shell 脚本），用于构建过程中专门需要的目标平台，而不是构建的最终产品在目标系统上运行。您可以将此类依赖项安装为 BuildDependency。请记住，它们不会被添加为生成的 JLL 包的依赖项；\n在构建过程中专门需要运行的二进制可执行文件。它们通常不能为目标平台构建，因此不能作为 Dependency 或 BuildDependency 安装。但是你有两个选择：\n如果它们在 x86_64-linux-musl 平台的 JLL 包中可用，您可以将它们安装为 HostBuildDependency。为了将目标平台的二进制文件与主机系统的二进制文件分开，这些依赖项将安装在 ${host_prefix} 下，特别是可执行文件将出现在 ${host_bindir} 下，它会自动添加到 ${PATH} 环境变量；\n如果它们存在于 Alpine Linux 存储库中，您可以使用系统包管理器 apk 安装它们。\n请记住，此类依赖项是为主机平台构建的：如果要为目标平台构建的库需要链接到另一个二进制库，将其安装为 HostBuildDependency 或 apk 将无济于事。","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"您需要了解要编译的包的构建过程，以便了解依赖项属于这些类中的哪些。","category":"page"},{"location":"build_tips/#安装许可证文件","page":"构建提示","title":"安装许可证文件","text":"","category":"section"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"生成的压缩包应该带有您要安装库的许可证。如果在成功构建结束时，${WORKSPACE}/srcdir 中只有一个目录，BinaryBuilder 将在其中查找具有典型许可证名称的文件（如 LICENSE、COPYRIGHT 等一些扩展组合）并自动将它们安装到 ${prefix}/share/licenses/${SRC_NAME}/。如果在最终的压缩包中，此目录中没有文件，则会发出警告，提醒您提供许可证文件。","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"如果许可证文件没有自动安装（例如，因为 ${WORKSPACE}/srcdir 中有多个目录，或者因为文件名与预期模式不匹配），您必须手动安装该文件。在构建脚本中，您可以使用 install_license 命令。请参阅下面的 构建环境中的实用程序 部分。","category":"page"},{"location":"build_tips/#utils_build_env","page":"构建提示","title":"构建环境中的实用程序","text":"","category":"section"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"除了标准的 Unix 工具之外，在构建环境中还有 BinaryBuilder 提供的一些额外命令。以下是其中一些命令的列表：","category":"page"},{"location":"build_tips/","page":"构建提示","title":"构建提示","text":"atomic_patch：应用补丁的实用程序。它类似于标准的 patch，但当无法应用补丁时它会优雅地失败：\natomic_patch -p1 /path/to/file.patch\nflagon：将一些编译器标志转换为当前平台所需的实用程序。例如，要从静态存档构建共享库：\ncc -o \"${libdir}/libfoo.${dlext}\" -Wl,$(flagon --whole-archive) libfoo.a -Wl,$(flagon --no-whole-archive) -lm\n当前支持的标记为：\n--whole-archive\n--no-whole-archive\n--relative-rpath-link\ninstall_license：将文件安装到 ${prefix}/share/licenses/${SRC_NAME} 的实用程序：\ninstall_license ${WORKSPACE}/srcdir/THIS_IS_THE_LICENSE.md\nupdate_configure_scripts：更新自动配置脚本的实用程序。有时库会附带过时的自动配置脚本（例如，旧的 configure.sub 无法识别 aarch64 平台或使用 Musl C 库的系统）。只需运行\nupdate_configure_scripts\n获得更新的版本。使用 --reconf 标志，它还会在之后运行 autoreconf -i -f：\nupdate_configure_scripts --reconf","category":"page"},{"location":"rootfs/#根文件系统","page":"根文件系统","title":"根文件系统","text":"","category":"section"},{"location":"rootfs/","page":"根文件系统","title":"根文件系统","text":"所有 BinaryBuilder.jl 构建所在的执行环境称为“根文件系统”或 RootFS。此 RootFS 由 Yggdrasil 中 0_Rootfs 目录 包含的构建器脚本构建的。 rootfs 镜像基于 alpine docker 镜像，用于为我们支持的每个目标平台构建编译器。目标平台编译器工具链存储在 /opt/${triplet} 中，因此 64 位 Linux（使用 glibc 作为支持 libc）编译器将在 /opt/x86_64-linux-gnu/bin 中找到。","category":"page"},{"location":"rootfs/","page":"根文件系统","title":"根文件系统","text":"每个编译器“分片”都是单独打包的，这样用户就不必为了构建单个平台而下载多 GB 的压缩包。有一个总的“根”分片，以及平台支持分片、GCC 分片、LLVM 分片、Rust 分片等...这些都嵌入在捆绑的 Artifacts.toml 文件，而 BinaryBuilder.jl 会按需下载它们，利用 Julia 1.3+ 的新 Pkg.Artifacts 系统。","category":"page"},{"location":"rootfs/","page":"根文件系统","title":"根文件系统","text":"每个分片都可以作为解压的目录树以及 .squashfs 图像使用。 .squashfs 图像占用的磁盘空间要少得多，但不幸的是，它们需要主机上的 root 权限，并且只能在 Linux 上运行。这有望在未来的 Linux 内核版本中得到修复，但如果您拥有 sudo 权限，通常需要使用 .squashfs 文件来节省网络带宽和磁盘空间。有关如何执行此操作的说明，请参阅 环境变量。","category":"page"},{"location":"rootfs/","page":"根文件系统","title":"根文件系统","text":"在 RootFS 映像中启动进程时，BinaryBuilder.jl 会设置一组环境变量以启用特定于目标的编译器工具链，以及其他细节。有关更多详细信息，请参阅 构建提示 文档页面，以及本仓库的 src/Runner.jl 文件。","category":"page"},{"location":"environment_variables/#环境变量","page":"环境变量","title":"环境变量","text":"","category":"section"},{"location":"environment_variables/","page":"环境变量","title":"环境变量","text":"BinaryBuilder.jl 支持多个环境变量来全局修改其行为：","category":"page"},{"location":"environment_variables/","page":"环境变量","title":"环境变量","text":"BINARYBUILDER_AUTOMATIC_APPLE：当设置为 true 时，这会自动同意 Apple macOS SDK 许可协议，从而能够为 macOS 系统构建二进制对象。","category":"page"},{"location":"environment_variables/","page":"环境变量","title":"环境变量","text":"BINARYBUILDER_USE_SQUASHFS：当设置为 true 时，这将使用 .squashfs 图像而不是压缩包来下载交叉编译器碎片。这占用的磁盘空间明显减少，下载大小也略有减少，但需要在本地机器上使用 sudo 来挂载 .squashfs 图像。这是使用“特权”运行程序时的默认设置。","category":"page"},{"location":"environment_variables/","page":"环境变量","title":"环境变量","text":"BINARYBUILDER_RUNNER：设置为运行器字符串时，会更改 BinaryBuilder.jl 将用于将构建过程包装在沙箱中的执行引擎。有效值为 \"userns\"、\"privileged\" 和 \"docker\" 中的一个。如果未给出，BinaryBuilder.jl 将尽力猜测。","category":"page"},{"location":"environment_variables/","page":"环境变量","title":"环境变量","text":"BINARYBUILDER_ALLOW_ECRYPTFS：当设置为 true 时，这允许从加密挂载中挂载 rootfs/shard/workspace 目录。这是默认禁用的，因为在撰写本文时，这会触发内核错误。为避免在主目录已加密的系统上出现这些内核错误，请将 BINARYBUILDER_ROOTFS_DIR 和 BINARYBUILDER_SHARDS_DIR 环境变量设置为加密主目录之外的路径。","category":"page"},{"location":"environment_variables/","page":"环境变量","title":"环境变量","text":"BINARYBUILDER_USE_CCACHE：当设置为 true 时，这会导致在构建环境中安装 /root/.ccache 卷，并且 CC、CXX 和 FC 环境变量具有 ccache 放在它们前面。这可以显着加快同一主机上同一包的重建。请注意，默认情况下，ccache 将存储 5G 的缓存数据。\nBINARYBUILDER_NPROC：覆盖构建期间设置的环境变量 ${nproc} 的值，请参阅自动环境变量。","category":"page"},{"location":"FAQ/#常见问题","page":"常见问题","title":"常见问题","text":"","category":"section"},{"location":"FAQ/#我在编译-project-name-here-时遇到问题","page":"常见问题","title":"我在编译 <project name here> 时遇到问题","text":"","category":"section"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"首先，确保您可以在您尝试编译它的任何平台上本地编译该项目。确保这点后，就在互联网上搜索，看看是否有其他人在为该平台交叉编译该项目时遇到问题。特别是，大多数较小的项目应该没问题，但较大的项目（尤其是任何进行任何类型的引导的项目）可能需要在其构建系统中加入一些额外的智能以支持交叉编译。最后，如果您仍然遇到困难，请尝试通过 JuliaLang slack 中的 #binarybuilder 频道 寻求帮助。","category":"page"},{"location":"FAQ/#我如何使用它来编译我的-Julia-代码？","page":"常见问题","title":"我如何使用它来编译我的 Julia 代码？","text":"","category":"section"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"这个包不编译 Julia 代码；它编译 C/C++/Fortran 依赖项。回想你使用 IJulia 并且需要下载/安装 libnettle 的时候。这个包的目的是使生成的压缩包可以尽可能轻松地下载/安装。","category":"page"},{"location":"FAQ/#我听说的-macOS-SDK-许可协议是什么？","page":"常见问题","title":"我听说的 macOS SDK 许可协议是什么？","text":"","category":"section"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"Apple 限制 macOS SDK 的分发和使用，这是为 macOS 目标构建软件的必要组件。请阅读Apple 与 Xcode SDK 协议 以获取更多有关使用 SDK 构建软件时您同意的限制和法律条款的信息适用于苹果操作系统。版权法是一个复杂的领域，您不应从互联网上的常见问题解答中获取法律建议。该工具包旨在主要在 Linux 上运行，但它当然可以在 macOS 机器上的虚拟化环境中使用，或者直接通过运行 Linux Apple 硬件来使用。 Docker runner 在 macOS 机器上实现虚拟化方法。默认情况下，BinaryBuilder.jl 不会在非苹果主机操作系统上自动下载或使用 macOS SDK，除非将 BINARYBUILDER_AUTOMATIC_APPLE 环境变量设置为 true。","category":"page"},{"location":"FAQ/#我可以使用其他环境变量吗？","page":"常见问题","title":"我可以使用其他环境变量吗？","text":"","category":"section"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"是的，看看这里。","category":"page"},{"location":"FAQ/#嘿，这很酷，我可以将它用于我的非-Julia-相关项目吗？","page":"常见问题","title":"嘿，这很酷，我可以将它用于我的非 Julia 相关项目吗？","text":"","category":"section"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"当然！ BinaryBuilder.jl 使用的交叉编译器生成的二进制文件与 Julia 无关。尽管与此软件交互的最佳界面始终是此包中定义的 Julia 界面，但您也可以自由地将这些软件工具用于其他项目。请注意，交叉编译器映像是通过多阶段引导过程构建的，有关详细信息，请参阅此存储库。进一步注意上面的 macOS SDK 许可协议。","category":"page"},{"location":"FAQ/#在第-XXX-行，中止（不允许操作）！","page":"常见问题","title":"在第 XXX 行，中止（不允许操作）！","text":"","category":"section"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"一些 linux 发行版在他们的 overlayfs 实现中有一个错误，阻止我们在用户命名空间中安装覆盖文件系统。请参阅此 Ubuntu 内核错误报告，了解有关情况的描述以及 Ubuntu 如何在其内核中对其进行修补。要解决此问题，您可以在“特权容器”模式下启动 BinaryBuilder.jl。 BinaryBuilder 应该会自动检测这种情况，但是如果自动检测不起作用或者您想消除警告，您可以将 BINARYBUILDER_RUNNER 环境变量设置为 privileged。不幸的是，这涉及在每次启动 BinaryBuilder 会话时运行 sudo，但另一方面，这成功地解决了 Arch linux 等发行版上的问题。","category":"page"},{"location":"FAQ/#我必须构建一个没有-Makefile-的非常小的项目，我该怎么办？","page":"常见问题","title":"我必须构建一个没有 Makefile 的非常小的项目，我该怎么办？","text":"","category":"section"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"BinaryBuilder 需要的是找到整理在 $prefix 目录下的相关文件（共享库或可执行文件等...）：库应该到 ${libdir}，可执行文件到 ${bindir}。您可能需要创建这些目录。您可以自由选择是创建一个简单的 Makefile 来构建项目，还是在 build_tarballs.jl 脚本中执行所有操作。","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"当脚本完成时，BinaryBuilder 期望在 ${libdir} 或 ${bindir} 中找到至少一个为预期架构构建的工件。","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"还请记住，您应该根据需要使用标准环境变量，如 CC、CXX、CFLAGS、LDFLAGS 以便交叉编译。请参阅 构建提示 部分中的变量列表。","category":"page"},{"location":"FAQ/#我可以在特定的构建环境中打开一个-shell-来进行一些快速测试吗？","page":"常见问题","title":"我可以在特定的构建环境中打开一个 shell 来进行一些快速测试吗？","text":"","category":"section"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"是的！您可以使用 BinaryBuilder.runshell(platform) 在当前目录中快速启动 shell，而无需设置有效的 build_tarballs.jl 脚本。例如，","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"julia -e 'using BinaryBuilder; BinaryBuilder.runshell(Platform(\"i686\", \"windows\"))'","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"将在 Windows 32 位构建环境中打开一个 shell，不加载任何源代码。您系统的当前工作目录将安装在此 BinaryBuilder 环境中的 ${WORKSPACE} 上。","category":"page"},{"location":"FAQ/#我可以在不通过-Yggdrasil-的情况下在本地发布-JLL-包吗？","page":"常见问题","title":"我可以在不通过 Yggdrasil 的情况下在本地发布 JLL 包吗？","text":"","category":"section"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"您始终可以使用 build_tarballs.jl 脚本的 --deploy 标志在您的机器上构建一个 JLL 包。阅读帮助 (--help) 了解更多信息。","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"一个常见的用例是，您想为 Libfoo 构建一个 JLL 包，它将用作构建 Quxlib 的依赖项，并且您想要确保同时构建 Libfoo 和 Quxlib 将在将所有拉取请求提交到 Yggdrasil 之前工作。您可以为 Libfoo 准备 build_tarballs.jl 脚本，然后使用","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"julia build_tarballs.jl --debug --verbose --deploy=\"MY_USERNAME/Libfoo_jll.jl\"","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"将 MY_USERNAME 替换为您的 GitHub 用户名：这将为所有请求的平台构建压缩包，并将它们上传到 MY_USERNAME/Libfoo_jll.jl 的版本，其中也将创建 JLL 包。如上所述，如果您只想编译其中的一些，您可以将参数传递给您要构建 tarball 的平台的三元组列表。在 Julia REPL 中，您可以将此包安装为任何未注册的包","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"]add https://github.com/MY_USERNAME/Libfoo_jll.jl.git","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"或开发它","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"]dev https://github.com/MY_USERNAME/Libfoo_jll.jl.git","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"由于此包未注册，您必须使用完整的 PackageSpec 规范将其添加为本地的依赖项 Quxlib 的构建器：","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"    Dependency(PackageSpec(; name = \"Libfoo_jll\",  uuid = \"...\", url = \"https://github.com/MY_USERNAME/Libfoo_jll.jl.git\"))","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"你当然可以反过来构建和部署这个包","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"julia build_tarballs.jl --debug --verbose --deploy=\"MY_USERNAME/Quxlib_jll.jl\"","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"请注意，PackageSpec 也可以指向本地路径：例如，PackageSpec(; name=\"Libfoo_jll\", uuid=\"...\", path=\"/home/myname/.julia/dev/Libfoo_jll\") .这在 在本地构建自定义 JLL 包 而不是将其部署到远程 Git 存储库时特别有用。","category":"page"},{"location":"FAQ/#源列表中的那些数字是什么？我如何得到它们？","page":"常见问题","title":"源列表中的那些数字是什么？我如何得到它们？","text":"","category":"section"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"源列表是 BinaryBuilder.AbstractSource 的向量。哈希值是什么取决于来源是什么：","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"对于 FileSource 或 ArchiveSource，哈希值是 64 个字符的 SHA256 校验和。如果您有该文件的副本，则可以使用 Julia 计算哈希值","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"julia   using SHA   open(path_to_the_file, \"r\") do f        bytes2hex(sha256(f))   end   其中 path_to_the_file 是包含文件路径的字符串。或者，您可以使用命令行实用程序 curl 和 shasum 来计算远程文件的哈希值：","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"$ curl -L http://example.org/file.tar.gz | shasum -a 256","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"将 http://example.org/file.tar.gz 替换为您要下载的文件的实际 URL。","category":"page"},{"location":"FAQ/","page":"常见问题","title":"常见问题","text":"对于 GitSource，哈希值是您要 check out 的修订版的 40 个字符的 SHA1 哈希值。为了可重复性，您必须指出特定的修订版，而不是分支或标签名称，它们是会改变的。","category":"page"},{"location":"jll/#JLL-包","page":"JLL 包","title":"JLL 包","text":"","category":"section"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"BinaryBuilder.jl 旨在生成可在任何环境中使用的压缩包，但到目前为止，它们的主要用途是提供预构建的库和可执行文件，以便在 Julia 包中轻松使用，这是通过 JLL 包完成的（JLL 是 “动态链接库” Dynamic-Link Library 的双关语，J 代表 Julia）。它们可以像其他 Julia 包一样通过 REPL 中的 Julia 包管理器 安装","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"]add NAME_jll","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"然后加载","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"using NAME_jll","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"但是，大多数用户永远不需要自己执行这些步骤，JLL 包通常仅用作封装二进制库或可执行文件的包的依赖项。","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"大多数 JLL 包都位于 GitHub 上的 JuliaBinaryWrappers 组织下，生成它们的构建器在 Yggdrasil, 社区构建树。 BinaryBuilder.jl 允许任何人创建自己的 JLL 包并将它们发布到他们选择的 GitHub 存储库，而无需使用 Yggdrasil，请参阅常见问题。","category":"page"},{"location":"jll/#JLL-包的剖析","page":"JLL 包","title":"JLL 包的剖析","text":"","category":"section"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"一个常见的误解是 JLL 包是“特殊的”。相反，它们是具有通用结构的简单 Julia 包，因为它们是自动生成的。下例为典型的 JLL 包树结构，其名称为 NAME_jll.jl：","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"NAME_jll\n├── Artifacts.toml\n├── LICENSE\n├── Project.toml\n├── README.md\n└── src/\n    ├── NAME_jll.jl\n    └── wrappers/\n        ├── aarch64-linux-gnu.jl\n        ├── aarch64-linux-musl.jl\n        ├── armv7l-linux-gnueabihf.jl\n        ├── armv7l-linux-musleabihf.jl\n        ├── i686-linux-gnu.jl\n        ├── i686-linux-musl.jl\n        ├── i686-w64-mingw32.jl\n        ├── powerpc64le-linux-gnu.jl\n        ├── x86_64-apple-darwin14.jl\n        ├── x86_64-linux-gnu.jl\n        ├── x86_64-linux-musl.jl\n        ├── x86_64-unknown-freebsd11.1.jl\n        └── x86_64-w64-mingw32.jl","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"这些是 JLL 包的主要成分：","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"LICENSE，一个说明 JLL 包许可证的文件。请注意，这可能与它封装的库的许可证不同，后者记录在压缩包中；\nREADME.md 文件提供了一些有关封装内容的信息，例如封装提供的“产品”列表；\nArtifacts.toml file 包含有关给定包的所有可用压缩包(tarball)的信息。压缩包将上传到 GitHub 发行页；\nProject.toml 文件描述了包的依赖关系及其兼容性；\n包的主要文件名为 src/NAME_jll.jl。\n这是您发出命令时执行的内容\nusing NAME_jll\n该文件读取 Artifacts.toml 中可用的压缩包列表，并选择与当前匹配的平台。某些 JLL 包并非为所有支持的平台构建。如果当前平台是 JLL 包不支持的平台之一，则调用结束。相反，如果支持当前平台，将包含 src/wrappers/ 目录中的相应封装器；\nwrappers/ 目录对每个平台提供一个文件。它们实际上大部分相同，由于特定于平台的细节而存在一些细微差别。下一节将更详细地分析封装器。","category":"page"},{"location":"jll/#封装器","page":"JLL 包","title":"封装器","text":"","category":"section"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"src/wrappers/ 目录中的文件是围绕 JLL 包提供的二进制包自动生成的非常轻巧封装器。它们加载作为当前 JLL 包依赖项的所有 JLL 包，并导出生成当前 JLL 包的 build_tarballs.jl 脚本中列出的产品名称。其中，它们还定义了以下未导出的变量：","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"artifact_dir: 当前工件安装的绝对路径平台。这是放置二进制文件/库/文件的“前缀”；\nPATH: 在当前 JLL 包中运行可执行文件所需的环境变量 PATH 的值（如果有的话）；\nPATH_list: PATH 中的目录列表，作为 String 向量；\nLIBPATH: 记录一列环境变量的取值用于共享库搜索，这里是当前 JLL 包提供库的正确值；\nLIBPATH_list：LIBPATH 中的目录列表，作为 String 的向量。","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"每个平台的封装文件还定义了 __init__() 函数JLL 包的，每次加载包时执行该代码。 __init__() 函数将填充上述大部分变量，并自动打开生成 JLL 包的 build_tarballs.jl 脚本产品中列出的共享库（如果存在的话）。","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"封装器中的其余代码特定于 JLL 包的每个产品，详情如下。如果您想查看提供所有主要三种产品的包的具体示例，请查看 Fontconfig_jll.jl。","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"除了上面每个 JLL 封装器定义的变量外，JLLWrappers 还定义了一个额外的未导出变量：","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"LIBPATH_env: 当前平台共享库的搜索路径的环境变量名。这等于 Linux 和 FreeBSD 上的 LD_LIBRARY_PATH、macOS 上的 DYLD_FALLBACK_LIBRARY_PATH 和 Windows 上的 PATH。","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"在下文中，我们将以拥有这些产品的构建为例：","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"products = [\n    FileProduct(\"src/data.txt\", :data_txt),\n    LibraryProduct(\"libdataproc\", :libdataproc),\n    ExecutableProduct(\"mungify\", :mungify_exe),\n]","category":"page"},{"location":"jll/#库产品","page":"JLL 包","title":"库产品","text":"","category":"section"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"LibraryProduct 是一个共享库，可以通过 Julia ccall 编辑。假设产品名为 libdataproc，封装器定义了以下变量：","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"libdataproc：这是应在 ccall中使用的被导出的“静态”变量:\nnum_chars = ccall((:count_characters, libdataproc), Cint,\n                  (Cstring, Cint), data_lines[1], length(data_lines[1]))\n粗略地说，这个变量的值是共享库的基本名称，而不是它的完整绝对路径；","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"libdataproc_path：共享库的完整绝对路径。注意这不是 const，因此不能在 ccall 中使用；\nlibdataproc_handle: 共享库在初始化阶段加载后的内存地址。","category":"page"},{"location":"jll/#可执行产品","page":"JLL 包","title":"可执行产品","text":"","category":"section"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"ExecutableProduct 是可以在当前平台上运行的二进制可执行文件。例如，如果 ExecutableProduct 被称为 mungify_exe，则封装器定义一个名为 mungify_exe 的导出函数，用户应通过以下方式运行该函数：","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"# Only available in Julia v1.6+\nrun(`$(mungify_exe()) $arguments`)","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"mungify_exe() do exe\n    run(`$exe $arguments`)\nend","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"请注意，在后一种形式中，exe 可以替换为您选择的任何名称：通过 do-block 语法，您正在定义将用于实际调用二进制文件的变量的名称 run。","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"前一种形式仅在使用 Julia v1.6 时可用，但在未来应该是首选，因为它是线程安全的并且通常更灵活。","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"关于 JLL 包 ExecutableProduct 的一个常见混淆点是为什么需要这些函数封装器：虽然原则上您可以通过在 run 中使用其绝对路径直接运行可执行文件，但这些函数确保可执行文件将找到所有共享运行时需要的库。","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"除了名为 mungify_exe 的函数外，对于该产品，还有以下未导出的变量：","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"mungify_exe_path：可执行文件的完整绝对路径；","category":"page"},{"location":"jll/#文件产品","page":"JLL 包","title":"文件产品","text":"","category":"section"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"FileProduct 是一个没有特殊处理的简单文件。例如，如果 FileProduct 被称为 data_txt，则为其定义的唯一变量是：","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"data_txt: 这个导出的变量有指定文件的绝对路径：\ndata_lines = open(data_txt, \"r\") do io\n    readlines(io)\nend\ndata_txt_path：这个未导出的变量实际上等于 data_txt，但用于保持与所有其他产品类型的一致性。","category":"page"},{"location":"jll/#覆盖-JLL-包中的工件","page":"JLL 包","title":"覆盖 JLL 包中的工件","text":"","category":"section"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"如上所述，JLL 包使用 Artifacts 系统 来提供文件。如果你想用自己的二进制文件/库/文件覆盖工件的内容，你可以使用 Overrides.toml 文件.","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"我们在下面详细介绍了几种不同的方法来覆盖 JLL 包的工件，具体取决于包是否是“开发”的。第二种方法特别推荐给希望使用系统库代替 JLL 包中的库的系统管理员。","category":"page"},{"location":"jll/#“dev”过的-JLL-包","page":"JLL 包","title":"“dev”过的 JLL 包","text":"","category":"section"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"如果用户希望覆盖“开发”的 JLL 包中的内容，用户可以使用 JLL 包提供的 dev_jll() 方法将包的可变副本检出到他们的 ~/ .julia/dev 目录。该包目录中将创建一个 override 目录，为用户提供一个方便的位置，以便将他们自己的文件复制到通常的工件源文件上。有关此功能的更多信息，请参阅本文档的 构建包 部分中的“在本地构建和测试 JLL 包”部分。","category":"page"},{"location":"jll/#非“dev”过的-JLL-包","page":"JLL 包","title":"非“dev”过的 JLL 包","text":"","category":"section"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"例如，在 Linux 系统中，您可以覆盖 Fontconfig_jll.jl 提供的 Fontconfig 库和 Bzip2_jll.jl 提供的 Bzip2 库，分别使用 /usr/lib/libfontconfig.so 和 /usr/local/lib/libbz2.so 以及以下 Overrides.toml：","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"[a3f928ae-7b40-5064-980b-68af3947d34b]\nFontconfig = \"/usr\"\n\n[6e34b625-4abd-537c-b88f-471c36dfa7a0]\nBzip2 = \"/usr/local\"","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"关于如何编写此文件的一些评论：","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"UUID 是 JLL 包的 UUID，\na3f928ae-7b40-5064-980b-68af3947d34b 用于 Fontconfig_jll.jl，而 6e34b625-4abd-537c-b88f-471c36dfa7a0 用于 Bzip2_jll.jl。您可以在包的 Project.toml 文件中找到它们（例如，参见 Fontconfig_jll 的 Project.toml 文件）或在注册表中查找（例如，请参阅General 注册表中 Fontconfig_jll 的条目)。\nJLL packages 提供的 artifacts 与 packages 同名，在这种情况下，没有后缀 _jll、 Fontconfig 和 Bzip2。\n工件位置保存在上面提到的 artifact_dir 变量中，这是软件包安装的“前缀”。回想一下，JLL 包中产品的路径是相对于 artifact_dir 的，您要用于覆盖 JLL 包产品的文件必须具有与工件相同的树结构。在我们的示例中，我们需要使用 /usr 覆盖 Fontconfig 和 /usr/local 用于 Bzip2。","category":"page"},{"location":"jll/#覆盖特定产品","page":"JLL 包","title":"覆盖特定产品","text":"","category":"section"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"您可以使用 Preferences.jl 覆盖 JLL 中的特定产品（库、可执行文件或文件），而不是覆盖整个工件。","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"compat: Compat\n本节需要 Julia 1.6 或更高版本。","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"作为例子，要覆盖我们的 libbz2：","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"using Preferences\nset_preferences!(\n    \"LocalPreferences.toml\",\n    \"Bzip2_jll\",\n    \"libbzip2_path\" => \"/usr/local/lib/libbz2.so\",\n)","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"请注意，产品名称是 libbzip2，但我们使用 libbzip2_path。","category":"page"},{"location":"jll/","page":"JLL 包","title":"JLL 包","text":"warning: Warning\n在两种常见情况下这将不起作用：JLL 是 Julia stdlib 的一部分，例如 Zlib_jll\nJLL 尚未使用 JLLWrappers.jl 作为依赖项进行编译。在这种情况下，这意味着 JLL 的最后一次构建早于 JLLWrappers 包的引入，需要重新构建。请在 Yggdrasil 上提出问题请求新构建，或提出拉取请求以更新相关的 build_tarballs.jl 脚本。","category":"page"},{"location":"reference/#参考-API","page":"引用","title":"参考 API","text":"","category":"section"},{"location":"reference/","page":"引用","title":"引用","text":"译注：以下是自动生成的函数注释，也可以在 REPL 中通过 help 模式查看。","category":"page"},{"location":"reference/#类型","page":"引用","title":"类型","text":"","category":"section"},{"location":"reference/","page":"引用","title":"引用","text":"Modules = [BinaryBuilderBase, BinaryBuilder, BinaryBuilder.Auditor, BinaryBuilder.Wizard]\nOrder = [:type]","category":"page"},{"location":"reference/#BinaryBuilderBase.AbstractDependency","page":"引用","title":"BinaryBuilderBase.AbstractDependency","text":"An AbstractDependency is a binary dependency of the JLL package.  Dependencies are installed to ${prefix} in the build environment.\n\nConcrete subtypes of AbstractDependency are\n\nDependency: a JLL package that is necessary for to build the package and to load the generated JLL package.\nRuntimeDependency: a JLL package that is necessary only at runtime.  Its artifact will not be installed in the prefix during the build.\nBuildDependency: a JLL package that is necessary only to build the package.  This will not be a dependency of the generated JLL package.\nHostBuildDependency: similar to BuildDependency, but it will install the artifact for the host platform, instead of that for the target platform.\n\nSubtypes of AbstractDependency should define the following traits:\n\nis_host_dependency\nis_target_dependency\nis_build_dependency\nis_runtime_dependency\n[is_top_level_dependency][@ref]\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.AbstractSource","page":"引用","title":"BinaryBuilderBase.AbstractSource","text":"An AbstractSource is something used as source to build the package.  Sources are installed to ${WORKSPACE}/srcdir in the build environment.\n\nConcrete subtypes of AbstractSource are:\n\nArchiveSource: a remote archive to download from the Internet;\nFileSource: a remote file to download from the Internet;\nGitSource: a remote Git repository to clone;\nDirectorySource: a local directory to mount.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.AnyPlatform","page":"引用","title":"BinaryBuilderBase.AnyPlatform","text":"AnyPlatform()\n\nA special platform to be used to build platform-independent tarballs, like those containing only header files.  FileProduct is the only product type allowed with this platform.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.ArchiveSource","page":"引用","title":"BinaryBuilderBase.ArchiveSource","text":"ArchiveSource(url::String, hash::String; unpack_target::String = \"\")\n\nSpecify a remote archive in one of the supported archive formats (e.g., TAR or ZIP balls) to be downloaded from the Internet from url.  hash is the 64-character SHA256 checksum of the file.\n\nIn the builder environment, the archive will be automatically unpacked to ${WORKSPACE}/srcdir, or in its subdirectory pointed to by the optional keyword unpack_target, if provided.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.BuildDependency","page":"引用","title":"BinaryBuilderBase.BuildDependency","text":"BuildDependency(dep::Union{PackageSpec,String}; platforms)\n\nDefine a binary dependency that is necessary only to build the package.  The dep argument can be either a string with the name of the JLL package or a Pkg.PackageSpec.\n\nThe optional keyword argument platforms is a vector of AbstractPlatforms which indicates for which platforms the dependency should be used.  By default platforms=[AnyPlatform()], to mean that the dependency is compatible with all platforms.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.Dependency","page":"引用","title":"BinaryBuilderBase.Dependency","text":"Dependency(dep::Union{PackageSpec,String}, build_version::VersionNumber;\n           compat::String, platforms::Vector{<:AbstractPlatform})\n\nDefine a binary dependency that is necessary to build the package and load the generated JLL package.  The argument can be either a string with the name of the JLL package or a Pkg.PackageSpec.\n\nThe optional positional argument build_version can be used to specify the version of the dependency to be installed when building it.  If not specified, the latest version of the package compatible with the environment will be automatically chosen by the package resolver, unless compat is specified, see below.\n\nThe optional keyword argument compat can be used to specify a string for use in the Project.toml of the generated Julia package.  If compat is non-empty and build_version is not passed, the latter defaults to the minimum version compatible with the compat specifier.\n\nThe optional keyword argument platforms is a vector of AbstractPlatforms which indicates for which platforms the dependency should be used.  By default platforms=[AnyPlatform()], to mean that the dependency is compatible with all platforms.\n\nThe optional keyword argument top_level denotates that this dependency is platform independent. It implies that the platforms keyword argument is set to [AnyPlatform()]. The primary use-case is for packages that hold information about the platform selection using Preferences. Platform selection is cached and in the case that no platform is available we need to be able to invalidate said cache. Invalidation occurs through the package that owns the Preferences data.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.DirectorySource","page":"引用","title":"BinaryBuilderBase.DirectorySource","text":"DirectorySource(path::String; target::String = basename(path), follow_symlinks=false)\n\nSpecify a local directory to mount from path.\n\nThe content of the directory will be mounted in ${WORKSPACE}/srcdir, or in its subdirectory pointed to by the optional keyword target, if provided. Symbolic links are replaced by a copy of the target when follow_symlinks is true.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.DockerRunner","page":"引用","title":"BinaryBuilderBase.DockerRunner","text":"DockerRunner\n\nUse docker as an execution engine; a reasonable backup for platforms that do not have user namespaces (e.g. MacOS, Windows).\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.ExecutableProduct","page":"引用","title":"BinaryBuilderBase.ExecutableProduct","text":"An ExecutableProduct is a Product that represents an executable file.\n\nOn all platforms, an ExecutableProduct checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set.  On Windows platforms, it will check that the file ends with \".exe\", (adding it on automatically, if it is not already present).\n\n\n\nExecutableProduct(binname, varname::Symbol, dir_path=\"bin\")\n\nDeclares an ExecutableProduct that points to an executable located within the prefix.  binname specifies the basename of the executable, varname is the name of the variable in the JLL package that can be used to call into the library.  By default, the library is searched in the bindir, but you can specify a different directory within the prefix with the dir_path argument.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.FileProduct","page":"引用","title":"BinaryBuilderBase.FileProduct","text":"FileProduct(path::AbstractString, varname::Symbol, dir_path = nothing)\n\nDeclares a FileProduct that points to a file located relative to the root of a Prefix, must simply exist to be satisfied.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.FileSource","page":"引用","title":"BinaryBuilderBase.FileSource","text":"FileSource(url::String, hash::String; filename::String = basename(url))\n\nSpecify a remote file to be downloaded from the Internet from url.  hash is the 64-character SHA256 checksum of the file.\n\nIn the builder environment, the file will be saved under ${WORKSPACE}/srcdir with the same name as the basename of the originating URL, unless the the keyword argument filename is specified.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.FrameworkProduct","page":"引用","title":"BinaryBuilderBase.FrameworkProduct","text":"A FrameworkProduct is a  Product that encapsulates a macOS Framework. It behaves mostly as a LibraryProduct for now, but is a distinct type. This implies that for cross-platform builds where a library is provided as a Framework on macOS and as a normal library on other platforms, two calls to BinaryBuilder's build_tarballs are needed: one with the LibraryProduct and all non-macOS platforms, and one with the FrameworkProduct and the MacOS platforms.\n\n\n\nFrameworkProduct(fwnames, varname::Symbol)\n\nDeclares a macOS FrameworkProduct that points to a framework located within the prefix, with a name containing fwname appended with .framework.  As an example, given that fwname is equal to QtCore, this would be satisfied by the following path:\n\nlib/QtCore.framework\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.GitSource","page":"引用","title":"BinaryBuilderBase.GitSource","text":"GitSource(url::String, hash::String; unpack_target::String = \"\")\n\nSpecify a remote Git repository to clone form url.  hash is the 40-character SHA1 revision to checkout after cloning.\n\nThe repository will be cloned in ${WORKSPACE}/srcdir, or in its subdirectory pointed to by the optional keyword unpack_target, if provided.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.HostBuildDependency","page":"引用","title":"BinaryBuilderBase.HostBuildDependency","text":"HostBuildDependency(dep::Union{PackageSpec,String}; platforms)\n\nDefine a binary dependency that is necessary only to build the package. Different from the BuildDependency, the artifact for the host platform will be installed, instead of that for the target platform.\n\nThe dep argument can be either a string with the name of the JLL package or a Pkg.PackageSpec.\n\nThe optional keyword argument platforms is a vector of AbstractPlatforms which indicates for which platforms the dependency should be used.  By default platforms=[AnyPlatform()], to mean that the dependency is compatible with all platforms.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.LibraryProduct","page":"引用","title":"BinaryBuilderBase.LibraryProduct","text":"A LibraryProduct is a special kind of Product that not only needs to exist, but needs to be dlopen()'able.  You must know which directory the library will be installed to, and its name, e.g. to build a LibraryProduct that refers to \"/lib/libnettle.so\", the \"directory\" would be \"/lib\", and the \"libname\" would be \"libnettle\".  Note that a LibraryProduct can support multiple libnames, as some software projects change the libname based on the build configuration.\n\n\n\nLibraryProduct(libname, varname::Symbol; dir_paths=String[],\n                                         dont_dlopen=false,\n                                         dlopen_flags=Symbol[])\n\nDeclares a LibraryProduct that points to a library located within the prefix. libname specifies the basename of the library, varname is the name of the variable in the JLL package that can be used to call into the library.  By default, the library is searched in the libdir, but you can add other directories within the prefix to the dir_paths keyword argument.  You can specify the flags to pass to dlopen as a vector of Symbols with the dlopen_flags keyword argument.  If the library should not be dlopen'ed automatically by the JLL package, set dont_dlopen=true.\n\nFor example, if the libname is libnettle, this would be satisfied by the following paths:\n\nlib/libnettle.so or lib/libnettle.so.6 on Linux and FreeBSD;\nlib/libnettle.6.dylib on macOS;\nlib/libnettle-6.dll on Windows.\n\nLibraries matching the search pattern are rejected if they are not dlopen()'able.\n\nIf you are unsure what value to use for libname, you can use Base.BinaryPlatforms.parse_dl_name_version:\n\njulia> using Base.BinaryPlatforms\n\njulia> parse_dl_name_version(\"sfml-audio-2.dll\", \"windows\")[1]\n\"sfml-audio\"\n\nIf the library would have different basenames on different operating systems (e.g., libz.so on Linux and FreeBSD, libz.dylib on macOS, and zlib.dll on Windows), libname can be also a vector of Strings with the different alternatives:\n\nLibraryProduct([\"libz\", \"zlib\"], :libz)\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.Product","page":"引用","title":"BinaryBuilderBase.Product","text":"A Product is an expected result after building or installation of a package.\n\nExamples of Products include LibraryProduct, FrameworkProduct, ExecutableProduct and FileProduct. All Product types must define the following minimum set of functionality:\n\nlocate(::Product): given a Product, locate it within the wrapped Prefix returning its location as a string\nsatisfied(::Product): given a Product, determine whether it has been successfully satisfied (e.g. it is locateable and it passes all callbacks)\nvariable_name(::Product): return the variable name assigned to a Product\nrepr(::Product): Return a representation of this Product, useful for auto-generating source code that constructs Products, if that's your thing.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.RuntimeDependency","page":"引用","title":"BinaryBuilderBase.RuntimeDependency","text":"RuntimeDependency(dep::Union{PackageSpec,String}; compat::String, platforms::Vector{<:AbstractPlatform}, top_level::Bool=false)\n\nDefine a binary dependency that is only listed as dependency of the generated JLL package, but its artifact is not installed in the prefix during the build.  The dep argument can be either a string with the name of the JLL package or a Pkg.PackageSpec.\n\nThe optional keyword argument compat can be used to specify a string for use in the Project.toml of the generated Julia package.\n\nThe optional keyword argument platforms is a vector of AbstractPlatforms which indicates for which platforms the dependency should be used.  By default platforms=[AnyPlatform()], to mean that the dependency is compatible with all platforms.\n\nThe optional keyword argument top_level specifies whether the dependency should be use only at the top-level of the generated JLL package, instead of inside each platform-specific wrapper.  Using top_level=true is useful for packages needed for platform augmentation (e.g. MPIPreferences.jl).\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.UserNSRunner","page":"引用","title":"BinaryBuilderBase.UserNSRunner","text":"UserNSRunner\n\nA UserNSRunner represents an \"execution context\", an object that bundles all necessary information to run commands within the container that contains our crossbuild environment.  Use run() to actually run commands within the UserNSRunner, and runshell() as a quick way to get an interactive shell within the crossbuild environment.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.Wizard.WizardState","page":"引用","title":"BinaryBuilder.Wizard.WizardState","text":"WizardState\n\nBuilding large dependencies can take a lot of time. This state object captures all relevant state of this function. It can be passed back to the function to resume where we left off. This can aid debugging when code changes are necessary.  It also holds all necessary metadata such as input/output streams.\n\n\n\n\n\n","category":"type"},{"location":"reference/#函数","page":"引用","title":"函数","text":"","category":"section"},{"location":"reference/","page":"引用","title":"引用","text":"Modules = [BinaryBuilderBase, BinaryBuilder, BinaryBuilder.Auditor, BinaryBuilder.Wizard]\nOrder = [:function]\n# We'll include build_tarballs explicitly below, so let's exclude it here:\nFilter = x -> !(isa(x, Function) && x === build_tarballs)","category":"page"},{"location":"reference/#BinaryBuilderBase.abi_agnostic-Tuple{Platform}","page":"引用","title":"BinaryBuilderBase.abi_agnostic","text":"abi_agnostic(p::AbstractPlatform)\n\nStrip out any tags that are not the basic annotations like libc and call_abi.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.accept_apple_sdk-Tuple{IO, IO}","page":"引用","title":"BinaryBuilderBase.accept_apple_sdk","text":"accept_apple_sdk(ins::IO, outs::IO) -> Bool\n\nAsk the user whether they accept the terms of the macOS SDK, and return a boolean with their choice.  Write messages to outs, read input from ins.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.artifact_name-Tuple{CompilerShard}","page":"引用","title":"BinaryBuilderBase.artifact_name","text":"artifact_name(cs::CompilerShard)\n\nReturn the bound artifact name for a particular shard.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.bindir-Tuple{Prefix}","page":"引用","title":"BinaryBuilderBase.bindir","text":"bindir(prefix::Prefix)\n\nReturns the binary directory for the given prefix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.choose_shards-Tuple{AbstractPlatform}","page":"引用","title":"BinaryBuilderBase.choose_shards","text":"choose_shards(p::AbstractPlatform; rootfs_build, ps_build, GCC_builds,\n                           LLVM_builds, archive_type)\n\nThis method chooses, given a Platform, which shards to download, extract and mount, returning a list of CompilerShard objects.  At the moment, this always consists of four shards, but that may not always be the case.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.chown_cleanup-Tuple{DockerRunner}","page":"引用","title":"BinaryBuilderBase.chown_cleanup","text":"chown_cleanup(dr::DockerRunner)\n\nOn Linux, the user id inside of the docker container doesn't correspond to ours on the outside, so permissions get all kinds of screwed up.  To fix this, we have to chown -R $(id -u):$(id -g) $prefix, which really sucks, but is still better than nothing.  This is why we prefer the UserNSRunner on Linux.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.collect_jll_uuids-Tuple{Pkg.Types.Manifest, Set{Base.UUID}}","page":"引用","title":"BinaryBuilderBase.collect_jll_uuids","text":"collect_jll_uuids(manifest::Pkg.Types.Manifest, dependencies::Set{Base.UUID})\n\nReturn a Set of all JLL packages in the manifest with dependencies being the list of direct dependencies of the environment.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.compress_dir-Tuple{AbstractString}","page":"引用","title":"BinaryBuilderBase.compress_dir","text":"compress_dir(dir::AbstractString;\n             compressor_stream = GzipCompressorStream,\n             level::Int = 9,\n             extension::AbstractString = \".gz\",\n             verbose::Bool = false)\n\nCompress all files in dir using the specified compressor_stream with compression level equal to level, appending extension to the filenames. Remove the original uncompressed files at the end.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.download_all_artifacts-Tuple{}","page":"引用","title":"BinaryBuilderBase.download_all_artifacts","text":"download_all_artifacts(; verbose::Bool=false)\n\nHelper function to download all shards/helper binaries so that no matter what happens, you don't need an internet connection to build your precious, precious binaries.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.download_source","page":"引用","title":"BinaryBuilderBase.download_source","text":"download_source(source::AbstractSource; verbose::Bool = false)\n\nDownload the given source.  All downloads are cached within the BinaryBuilder downloads storage directory.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.enable_apple_file-Tuple{}","page":"引用","title":"BinaryBuilderBase.enable_apple_file","text":"enable_apple_file()\n\nReturn the path to file that, if exists, indicates that the user accepts to download macOS SDK.  The file is automatically created when the package is loaded if the environment variable BINARYBUILDER_AUTOMATIC_APPLE is set to \"true\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.expand_cxxstring_abis-Tuple{AbstractPlatform}","page":"引用","title":"BinaryBuilderBase.expand_cxxstring_abis","text":"expand_cxxstring_abis(p::AbstractPlatform; skip=Sys.isbsd)\n\nGiven a Platform, returns an array of Platforms with a spread of identical entries with the exception of the cxxstring_abi tag within the Platform object.  This is used to take, for example, a list of supported platforms and expand them to include multiple GCC versions for the purposes of ABI matching.\n\nIf the given Platform already specifies a cxxstring_abi (as opposed to nothing) only that Platform is returned.  If skip is a function for which skip(platform) evaluates to true, the given platform is not expanded.  By default FreeBSD and macOS platforms are skipped, due to their lack of a dependence on libstdc++ and not needing this compatibility shim.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.expand_gfortran_versions-Tuple{AbstractPlatform}","page":"引用","title":"BinaryBuilderBase.expand_gfortran_versions","text":"expand_gfortran_versions(p::AbstractPlatform)\n\nGiven a Platform, returns an array of Platforms with a spread of identical entries with the exception of the libgfortran_version tag within the Platform.  This is used to take, for example, a list of supported platforms and expand them to include multiple GCC versions for the purposes of ABI matching.  If the given Platform already specifies a libgfortran_version (as opposed to nothing) only that Platform is returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.expand_microarchitectures","page":"引用","title":"BinaryBuilderBase.expand_microarchitectures","text":"expand_microarchitectures(p::AbstractPlatform, [microarchitectures::Vector{String}])\n\nGiven a Platform, returns a vector of Platforms with differing march attributes as specified by the ARCHITECTURE_FLAGS mapping.  If the given Platform alread has a march tag specified, only that platform is returned.  If the microarchitectures argument is given, limit the expansion to the given microarchitectures.\n\njulia> using BinaryBuilderBase\n\njulia> expand_microarchitectures(Platform(\"x86_64\", \"freebsd\"))\n4-element Vector{Platform}:\n FreeBSD x86_64 {march=x86_64}\n FreeBSD x86_64 {march=avx}\n FreeBSD x86_64 {march=avx2}\n FreeBSD x86_64 {march=avx512}\n\njulia> expand_microarchitectures(Platform(\"armv7l\", \"linux\"))\n2-element Vector{Platform}:\n Linux armv7l {call_abi=eabihf, libc=glibc, march=armv7l}\n Linux armv7l {call_abi=eabihf, libc=glibc, march=neonvfpv4}\n\njulia> expand_microarchitectures(Platform(\"aarch64\", \"linux\"), [\"armv8_0\", \"a64fx\"])\n2-element Vector{Platform}:\n Linux aarch64 {libc=glibc, march=armv8_0}\n Linux aarch64 {libc=glibc, march=a64fx}\n\njulia> expand_microarchitectures(Platform(\"i686\", \"windows\"))\n2-element Vector{Platform}:\n Windows i686 {march=pentium4}\n Windows i686 {march=prescott}\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.expand_microarchitectures-2","page":"引用","title":"BinaryBuilderBase.expand_microarchitectures","text":"expand_microarchitectures(ps::Vector{<:Platform}, [microarchitectures::Vector{String}];\n                          filter=Returns(true))\n\nExpand all platforms in the vector ps with the supported microarchitectures.\n\nIf the microarchitectures argument is given, limit the expansion to the given platforms.  This is useful if you do not want to expand to all available microarchitectures.\n\nThe expansion is applied only to the platforms matching the filter predicate, by default all platforms.  This is useful if you want to limit the expansion to some platforms, without having to explicitly list its microarchitectures in the second argument.\n\njulia> using BinaryBuilderBase\n\njulia> expand_microarchitectures(filter!(p -> Sys.islinux(p) && libc(p) == \"glibc\", supported_platforms()))\n14-element Vector{Platform}:\n Linux i686 {libc=glibc, march=pentium4}\n Linux i686 {libc=glibc, march=prescott}\n Linux x86_64 {libc=glibc, march=x86_64}\n Linux x86_64 {libc=glibc, march=avx}\n Linux x86_64 {libc=glibc, march=avx2}\n Linux x86_64 {libc=glibc, march=avx512}\n Linux aarch64 {libc=glibc, march=armv8_0}\n Linux aarch64 {libc=glibc, march=armv8_1}\n Linux aarch64 {libc=glibc, march=armv8_2_crypto}\n Linux aarch64 {libc=glibc, march=a64fx}\n Linux armv6l {call_abi=eabihf, libc=glibc, march=arm1176jzfs}\n Linux armv7l {call_abi=eabihf, libc=glibc, march=armv7l}\n Linux armv7l {call_abi=eabihf, libc=glibc, march=neonvfpv4}\n Linux powerpc64le {libc=glibc, march=power8}\n\njulia> expand_microarchitectures(filter!(p -> Sys.islinux(p) && libc(p) == \"glibc\", supported_platforms()), [\"x86_64\", \"avx2\"])\n7-element Vector{Platform}:\n Linux i686 {libc=glibc}\n Linux x86_64 {libc=glibc, march=x86_64}\n Linux x86_64 {libc=glibc, march=avx2}\n Linux aarch64 {libc=glibc}\n Linux armv6l {call_abi=eabihf, libc=glibc}\n Linux armv7l {call_abi=eabihf, libc=glibc}\n Linux powerpc64le {libc=glibc}\n\njulia> expand_microarchitectures(filter!(p -> Sys.islinux(p) && libc(p) == \"glibc\", supported_platforms()); filter=p->arch(p)==\"x86_64\")\n9-element Vector{Platform}:\n Linux i686 {libc=glibc}\n Linux x86_64 {libc=glibc, march=x86_64}\n Linux x86_64 {libc=glibc, march=avx}\n Linux x86_64 {libc=glibc, march=avx2}\n Linux x86_64 {libc=glibc, march=avx512}\n Linux aarch64 {libc=glibc}\n Linux armv6l {call_abi=eabihf, libc=glibc}\n Linux armv7l {call_abi=eabihf, libc=glibc}\n Linux powerpc64le {libc=glibc}\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.filter_platforms-Tuple{AbstractVector{<:AbstractDependency}, AbstractPlatform}","page":"引用","title":"BinaryBuilderBase.filter_platforms","text":"filter_platforms(deps::AbstractVector{<:AbstractDependency}, p::AbstractPlatform)\n\nFilter the dependencies deps which are compatible with platform p.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.gcc_version","page":"引用","title":"BinaryBuilderBase.gcc_version","text":"gcc_version(p::AbstractPlatform, GCC_builds::Vector{GCCBuild},\n            compilers::Vector{Symbol}=[:c];\n            llvm_version::Union{Nothing,VersionNumber}=nothing)\n\nReturns the closest matching GCC version number for the given particular platform, from the given set of options.  The compiler ABI and the microarchitecture of the platform will be taken into account.  If no match is found, returns an empty list.  compilers is the list of compilers used in the build, to choose the right version of GCC to couple with them if necessary.  If the keyword argument llvm_version is passed, it is used to filter the version of GCC for FreeBSD platforms.\n\nThis method assumes that the compiler ABI of the platform represents a platform that binaries will be run on, and thus versions are always rounded down; e.g. if the platform supports a libstdc++ version that corresponds to GCC 5.1.0, but the only GCC versions available to be picked from are 4.8.5 and 5.2.0, it will return 4.8.5, as binaries compiled with that version will run on this platform, whereas binaries compiled with 5.2.0 may not.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.generate_compiler_wrappers!-Tuple{AbstractPlatform}","page":"引用","title":"BinaryBuilderBase.generate_compiler_wrappers!","text":"generate_compiler_wrappers!(platform::AbstractPlatform; bin_path::AbstractString,\n                            host_platform::AbstractPlatform = Platform(\"x86_64\", \"linux\"; libc = \"musl\", cxxstring_abi = \"cxx11\"),\n                            compilers::Vector{Symbol} = [:c],\n                            allow_unsafe_flags::Bool = false,\n                            lock_microarchitecture::Bool = true)\n\nWe generate a set of compiler wrapper scripts within our build environment to force all build systems to honor the necessary sets of compiler flags to build for our systems. Note that while platform_envs() sets many environment variables, those values are intended to be optional/overridable.  These values, while still overridable by directly invoking a compiler binary directly (e.g. /opt/{target}/bin/{target}-gcc), are much more difficult to override, as the flags embedded in these wrappers are absolutely necessary, and even simple programs will not compile without them.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.generate_per_uid_squashfs","page":"引用","title":"BinaryBuilderBase.generate_per_uid_squashfs","text":"generate_per_uid_squashfs(cs, new_uid = getuid())\n\nIn order for the sandbox to work well, we need to have the uids of the squashfs images match the uid of the current unprivileged user.  Unfortunately there is no mount-time option to do this for us.  Fortunately, squashfs is simple enough that if the ID table is uncompressed, we can just manually patch the uids to be what we need.  This function performs this operation, by rewriting all UIDs and GIDs to the given new_uid (which defaults to the current user's UID).\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.get_addable_spec-Tuple{AbstractString, VersionNumber}","page":"引用","title":"BinaryBuilderBase.get_addable_spec","text":"get_addable_spec(name::AbstractString, version::VersionNumber)\n\nGiven a JLL name and registered version, return a PackageSpec that, when passed as a Dependency, ensures that exactly that version will be installed.  Example usage:\n\ndependencies = [\n    BuildDependency(get_addable_spec(\"LLVM_jll\", v\"9.0.1+0\")),\n]\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.get_commit_sha-Tuple{String, Base.SHA1}","page":"引用","title":"BinaryBuilderBase.get_commit_sha","text":"get_commit_sha(url::String, tree_hash::Base.SHA1; verbose::Bool=false)\n\nFind the latest git commit corresponding to the given git tree SHA1 for the remote repository with the given url.  The repository is cached locally for quicker future access.  If verbose is true, print to screen some debugging information.\n\nThe return value is the commit SHA as a String, if the corresponding revision is found, nothing otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.get_concrete_platform-Tuple{AbstractPlatform}","page":"引用","title":"BinaryBuilderBase.get_concrete_platform","text":"get_concrete_platform(platform::AbstractPlatform;\n                      preferred_gcc_version = nothing,\n                      preferred_llvm_version = nothing,\n                      compilers = nothing)\n\nReturn the concrete platform for the given platform based on the GCC compiler ABI.  The set of shards is chosen by the keyword arguments (see choose_shards).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.get_concrete_platform-Tuple{Platform, Vector{CompilerShard}}","page":"引用","title":"BinaryBuilderBase.get_concrete_platform","text":"get_concrete_platform(platform::Platform, shards::Vector{CompilerShard})\n\nReturn the concrete platform for the given platform based on the GCC compiler ABI in the shards.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.get_tree_hash-Tuple{LibGit2.GitTree}","page":"引用","title":"BinaryBuilderBase.get_tree_hash","text":"get_tree_hash(tree::LibGit2.GitTree)\n\nGiven a GitTree, get the GitHash that identifies it.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.getgid-Tuple{}","page":"引用","title":"BinaryBuilderBase.getgid","text":"getgid()\n\nWrapper around libc's getgid() function\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.getuid-Tuple{}","page":"引用","title":"BinaryBuilderBase.getuid","text":"getuid()\n\nWrapper around libc's getuid() function\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.import_docker_image-Tuple{CompilerShard, String}","page":"引用","title":"BinaryBuilderBase.import_docker_image","text":"import_docker_image(rootfs::CompilerShard; verbose::Bool = false)\n\nChecks to see if the given rootfs has been imported into docker yet; if it hasn't, then do so so that we can run things like:\n\ndocker run -ti binarybuilder_rootfs:v2018.08.27 /bin/bash\n\nWhich, after all, is the foundation upon which this whole doodad is built.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.includedir-Tuple{Prefix}","page":"引用","title":"BinaryBuilderBase.includedir","text":"includedir(prefix::Prefix)\n\nReturns the include directory for the given prefix\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.installed_shards-Tuple{}","page":"引用","title":"BinaryBuilderBase.installed_shards","text":"installed_shards()\n\nReturn a vector of compiler shards currently downloaded on the local system\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.is_build_dependency","page":"引用","title":"BinaryBuilderBase.is_build_dependency","text":"is_build_dependency(dep::AbstractDependency) -> Bool\n\nReturn whether dep is a build-time dependency or not.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.is_ecryptfs-Tuple{AbstractString}","page":"引用","title":"BinaryBuilderBase.is_ecryptfs","text":"is_ecryptfs(path::AbstractString; verbose::Bool=false)\n\nChecks to see if the given path (or any parent directory) is placed upon an ecryptfs mount.  This is known not to work on current kernels, see this bug for more details: https://bugzilla.kernel.org/show_bug.cgi?id=197603\n\nThis method returns whether it is encrypted or not, and what mountpoint it used to make that decision.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.is_host_dependency","page":"引用","title":"BinaryBuilderBase.is_host_dependency","text":"is_host_dependency(dep::AbstractDependency) -> Bool\n\nReturn whether dep is a dependency of the host platform or not.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.is_mounted-Tuple{CompilerShard, AbstractString}","page":"引用","title":"BinaryBuilderBase.is_mounted","text":"is_mounted(cs::CompilerShard, build_prefix::String)\n\nReturn true if the given shard is mounted.  Uses run() so will error out if something goes awry.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.is_runtime_dependency","page":"引用","title":"BinaryBuilderBase.is_runtime_dependency","text":"is_runtime_dependency(dep::AbstractDependency) -> Bool\n\nReturn whether dep is a runtime dependency or not.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.is_target_dependency-Tuple{AbstractDependency}","page":"引用","title":"BinaryBuilderBase.is_target_dependency","text":"is_target_dependency(dep::AbstractDependency) -> Bool\n\nReturn whether dep is a dependency of the target platform or not.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.is_top_level_dependency-Tuple{AbstractDependency}","page":"引用","title":"BinaryBuilderBase.is_top_level_dependency","text":"is_top_level_dependency(dep::AbstractDependency) -> Bool\n\nReturn wheter dep is a top-level dependency or not.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.libabi_agnostic-Tuple{Platform}","page":"引用","title":"BinaryBuilderBase.libabi_agnostic","text":"abi_agnostic(p::AbstractPlatform)\n\nLike abi_agnostic, but keep the sanitizer ABI tags.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.libdirs","page":"引用","title":"BinaryBuilderBase.libdirs","text":"libdirs(prefix::Prefix, platform = HostPlatform())\n\nReturns the library directories for the given prefix (note that this differs between unix systems and windows systems, and between 32- and 64-bit systems).\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.locate-Tuple{ExecutableProduct, Prefix}","page":"引用","title":"BinaryBuilderBase.locate","text":"locate(ep::ExecutableProduct, prefix::Prefix;\n       platform::AbstractPlatform = HostPlatform(),\n       verbose::Bool = false,\n       isolate::Bool = false)\n\nIf the given executable file exists and is executable, return its path.\n\nOn all platforms, an ExecutableProduct checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set. On Windows platforms, it will check that the file ends with \".exe\", (adding it on automatically, if it is not already present).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.locate-Tuple{FileProduct, Prefix}","page":"引用","title":"BinaryBuilderBase.locate","text":"locate(fp::FileProduct, prefix::Prefix;\n       platform::AbstractPlatform = HostPlatform(),\n       verbose::Bool = false,\n       isolate::Bool = false)\n\nIf the given file exists, return its path.  The platform and isolate arguments are is ignored here, but included for uniformity.  For ease of use, we support a limited number of custom variable expansions such as ${target}, and ${nbits}, so that the detection of files within target-specific folders named things like /lib32/i686-linux-musl is simpler.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.locate-Tuple{LibraryProduct, Prefix}","page":"引用","title":"BinaryBuilderBase.locate","text":"locate(lp::LibraryProduct, prefix::Prefix;\n       verbose::Bool = false,\n       platform::AbstractPlatform = HostPlatform())\n\nIf the given library exists (under any reasonable name) and is dlopen()able, (assuming it was built for the current platform) return its location.  Note that the dlopen() test is only run if the current platform matches the given platform keyword argument, as cross-compiled libraries cannot be dlopen()ed on foreign platforms.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.logdir-Tuple{Prefix}","page":"引用","title":"BinaryBuilderBase.logdir","text":"logdir(prefix::Prefix; subdir::AbstractString=\"\")\n\nReturns the logs directory for the given prefix.  If subdir is a non-empty string, that directory it is appended to the logdir of the given prefix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.macos_sdk_already_installed-Tuple{}","page":"引用","title":"BinaryBuilderBase.macos_sdk_already_installed","text":"macos_sdk_already_installed()\n\nReturns true if any piece of the MacOS SDK is already installed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.map_target-Tuple{CompilerShard}","page":"引用","title":"BinaryBuilderBase.map_target","text":"map_target(cs::CompilerShard)\n\nReturn the location this compiler shard should be mounted at.  We basically analyze the name and platform of this shard and return a path based on that.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.mount-Tuple{CompilerShard, AbstractString}","page":"引用","title":"BinaryBuilderBase.mount","text":"mount(cs::CompilerShard, build_prefix::String)\n\nMount a compiler shard, if possible.  Uses run() so will error out if something goes awry.  Note that this function only does something when using a .squashfs shard, with a UserNS or Docker runner, on Linux. All other combinations of shard archive type, runner and platform result in a no-op from this function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.package-Tuple{Prefix, AbstractString, VersionNumber}","page":"引用","title":"BinaryBuilderBase.package","text":"package(prefix::Prefix, output_base::AbstractString,\n        version::VersionNumber;\n        platform::AbstractPlatform = HostPlatform(),\n        verbose::Bool = false, force::Bool = false,\n        filter = Returns(true))\n\nBuild a tarball of the prefix, storing the tarball at output_base, appending the version number version, a platform-dependent suffix and a file extension.  If platform is not given, defaults to current platform. Returns the full path to, the SHA256 hash and the git tree SHA1 of the generated tarball.\n\nThe are additional keyword arguments:\n\nverbose controls whether to print information to screen,\nforce makes the function overwrite an existing tarball with the same name\nfilter is a 2-argument function which returns true if the given file or directory should be packaged, and false otherwise.  The arguments are (prefix, path), where prefix is the directory where the prefix is stored, and path is the path, within the prefix, of the file or directory.  This keyword allows you to filter out from the tarball certain files or directories.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.platform_envs-Tuple{AbstractPlatform, AbstractString}","page":"引用","title":"BinaryBuilderBase.platform_envs","text":"platform_envs(platform::AbstractPlatform, src_name::AbstractString;\n              host_platform = default_host_platform,\n              bootstrap::Bool=!isempty(bootstrap_list),\n              compilers::Vector{Symbol}=[:c],\n              rust_version::Union{Nothing,VersionNumber}=nothing,\n              verbose::Bool = false,\n              )\n\nGiven a platform and a src_name, generate a Dict mapping representing all the environment variables to be set within the build environment to force compiles toward the defined target architecture.  Examples of things set are PATH, CC, RANLIB, as well as nonstandard things like target.\n\nAccepted keyword arguments are:\n\nhost_platform: the platform of the host system,\nbootstraop: if true, only basic environment variables will be generated,\ncompilers: list of compilers, some environment variables will be generated only if the relevant compilers are used (e.g., for Go and Rust),\nrust_version: version of the Rust toolchain, needed to set the environment variable RUSTUP_TOOLCHAIN,\nverbose: holds the value of the V and VERBOSE environment variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.platform_exeext-Tuple{AbstractPlatform}","page":"引用","title":"BinaryBuilderBase.platform_exeext","text":"platform_exeext(p::AbstractPlatform)\n\nGet the executable extension for the given Platform.  Includes the leading ..\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.preferred_cxxstring_abi-Tuple{AbstractPlatform, CompilerShard}","page":"引用","title":"BinaryBuilderBase.preferred_cxxstring_abi","text":"preferred_cxxstring_abi(platform::AbstractPlatform, shard::CompilerShard;\n                        gcc_builds::Vector{GCCBuild} = available_gcc_builds)\n\nReturn the C++ string ABI preferred by the given platform or GCCBootstrap shard.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.preferred_libgfortran_version-Tuple{AbstractPlatform, CompilerShard}","page":"引用","title":"BinaryBuilderBase.preferred_libgfortran_version","text":"preferred_libgfortran_version(platform::AbstractPlatform, shard::CompilerShard;\n                              gcc_builds::Vector{GCCBuild} = available_gcc_builds)\n\nReturn the libgfortran version preferred by the given platform or GCCBootstrap shard.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.runshell","page":"引用","title":"BinaryBuilderBase.runshell","text":"runshell(platform::AbstractPlatform = HostPlatform())\n\nLaunch an interactive shell session within the user namespace, with environment setup to target the given platform.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.satisfied-Tuple{Product, Prefix}","page":"引用","title":"BinaryBuilderBase.satisfied","text":"satisfied(p::Product;\n          platform::AbstractPlatform = HostPlatform(),\n          verbose::Bool = false,\n          isolate::Bool = false)\n\nGiven a Product, return true if that Product is satisfied, e.g. whether a file exists that matches all criteria setup for that Product. If isolate is set to true, will isolate all checks from the main Julia process in the event that dlopen()'ing a library might cause issues.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.setup_workspace","page":"引用","title":"BinaryBuilderBase.setup_workspace","text":"setup_workspace(build_path::String, sources::Vector{SetupSource};\n                verbose::Bool = false)\n\nSets up a workspace within build_path, creating the directory structure needed by further steps, unpacking the source within build_path, and defining the environment variables that will be defined within the sandbox environment.\n\nThis method returns the Prefix to install things into, and the runner that can be used to launch commands within this workspace.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.shard_mappings-Tuple{Vector{CompilerShard}}","page":"引用","title":"BinaryBuilderBase.shard_mappings","text":"shard_mappings(shards::Vector{CompilerShard})\n\nReturn the default mappings for a set of compiler shards\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.shard_path-Tuple{CompilerShard}","page":"引用","title":"BinaryBuilderBase.shard_path","text":"shard_path(cs::CompilerShard)\n\nReturn the path to this shard on-disk; for unpacked shards, this is a directory. For squashfs shards, this is a file.  This will not cause a shard to be downloaded.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.supported_platforms-Tuple{}","page":"引用","title":"BinaryBuilderBase.supported_platforms","text":"supported_platforms(;exclude::Union{Vector{<:Platform},Function}=Returns(false),\n                    experimental::Bool=false)\n\nReturn the list of supported platforms as an array of Platforms.  These are the platforms we officially support building for, if you see a mapping in get_shard_hash() that isn't represented here, it's probably because that platform is still considered \"in beta\".  If experimental=true, include platforms considered experimental.\n\nPlatforms can be excluded from the list by specifying an array of platforms to exclude i.e. supported_platforms(exclude=[Platform(\"i686\", \"windows\"), Platform(\"x86_64\", \"windows\")]) or a function that returns true for exclusions i.e.\n\nsupported_platforms(exclude=Sys.islinux)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.temp_prefix-Tuple{Function}","page":"引用","title":"BinaryBuilderBase.temp_prefix","text":"temp_prefix(func::Function)\n\nCreate a temporary prefix, passing the prefix into the user-defined function so that build/packaging operations can occur within the temporary prefix, which is then cleaned up after all operations are finished.  If the path provided exists already, it will be deleted.\n\nUsage example:\n\nout_path = abspath(\"./libfoo\")\ntemp_prefix() do p\n    # <insert build steps here>\n\n    # tarball up the built package\n    tarball_path, tarball_hash = package(p, out_path)\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.uname-Tuple{}","page":"引用","title":"BinaryBuilderBase.uname","text":"uname()\n\nOn Linux systems, return the strings returned by the uname() function in libc\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.unmount-Tuple{CompilerShard, String}","page":"引用","title":"BinaryBuilderBase.unmount","text":"unmount(cs::CompilerShard, build_prefix::String)\n\nUnmount a compiler shard from a given build prefix, if possible.  Uses run() so will error out if something goes awry.  Note that this function only does something when using a squashfs shard on Linux.  All other combinations of shard archive type and platform result in a no-op.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.variable_name-Tuple{Product}","page":"引用","title":"BinaryBuilderBase.variable_name","text":"variable_name(p::Product)\n\nReturn the variable name associated with this Product as a string\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.versioninfo-Tuple{}","page":"引用","title":"BinaryBuilderBase.versioninfo","text":"versioninfo()\n\nHelper function to print out some debugging information\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.autobuild-Tuple{AbstractString, AbstractString, VersionNumber, Vector{<:AbstractSource}, AbstractString, Vector, Vector{<:Product}, Vector{<:AbstractDependency}}","page":"引用","title":"BinaryBuilder.autobuild","text":"autobuild(dir::AbstractString, src_name::AbstractString,\n          src_version::VersionNumber, sources::Vector,\n          script::AbstractString, platforms::Vector,\n          products::Vector, dependencies::Vector;\n          verbose = false, debug = false,\n          skip_audit = false, ignore_audit_errors = true,\n          autofix = true, code_dir = nothing,\n          meta_json_file = nothing, require_license = true,\n          dont_dlopen = false, kwargs...)\n\nRuns the boiler plate code to download, build, and package a source package for a list of platforms.  This method takes a veritable truckload of arguments, here are the relevant actors, broken down in brief:\n\ndir: the root of the build; products will be placed within dir/products,  and mountpoints will be placed within dir/build/.\nsrc_name: the name of the source package being built and will set the name  of the built tarballs.\nsrc_version: the version of the source package.\nplatforms: a list of platforms to build for.\nsources: a vector of all sources to download and unpack before building begins, as AbstractSources.\nscript: a string representing a shell script to run as the build.\nproducts: the list of Products which shall be built.\ndependencies: a vector of JLL dependency packages as AbstractDependency that should be installed before building begins.\nverbose: Enable verbose mode.  What did you expect?\ndebug: cause a failed build to drop into an interactive shell so that  the build can be inspected easily.\nskip_audit: disable the typical audit that occurs at the end of a build.\nignore_audit_errors: do not kill a build even if a problem is found.\nautofix: give BinaryBuilder permission to automatically fix issues it  finds during audit passes.  Highly recommended.\ncode_dir: sets where autogenerated JLL packages will be put.\nrequire_license enables a special audit pass that requires licenses to be  installed by all packages.\ndont_dlopen: don't try to dlopen library products. This is separate from  specifying dont_dlopen on a LibraryProduct in that it still results in  the generated JLL loading the library at run time, and only prevents  BinaryBuilder from doing so during JLL generation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.get_compilers_versions-Tuple{}","page":"引用","title":"BinaryBuilder.get_compilers_versions","text":"get_compilers_versions(; compilers = [:c])\n\nReturn the script string that is used to print the versions of the given compilers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.BinaryPlatforms.detect_cxxstring_abi-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}","page":"引用","title":"Base.BinaryPlatforms.detect_cxxstring_abi","text":"detect_cxxstring_abi(oh::ObjectHandle, platform::AbstractPlatform)\n\nGiven an ObjectFile, examine its symbols to discover which (if any) C++11 std::string ABI it's using.  We do this by scanning the list of exported symbols, triggering off of instances of St7__cxx11 or _ZNSs to give evidence toward a constraint on cxx11, cxx03 or neither.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.BinaryPlatforms.detect_libstdcxx_version-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}","page":"引用","title":"Base.BinaryPlatforms.detect_libstdcxx_version","text":"detect_libstdcxx_version(oh::ObjectHandle, platform::AbstractPlatform)\n\nGiven an ObjectFile, examine its dynamic linkage to discover which (if any) libgfortran it's linked against.  The major SOVERSION will determine which GCC version we're restricted to.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.analyze_instruction_set-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}","page":"引用","title":"BinaryBuilder.Auditor.analyze_instruction_set","text":"analyze_instruction_set(oh::ObjectHandle, platform::AbstractPlatform; verbose::Bool = false)\n\nAnalyze the instructions within the binary located at the given path for which minimum instruction set it requires, taking note of groups of instruction sets used such as avx, sse4.2, i486, etc....\n\nSome binary files (such as libopenblas) contain multiple versions of functions, internally determining which version to call by using the cpuid instruction to determine processor support.  In an effort to detect this, we make note of any usage of the cpuid instruction, disabling our minimum instruction set calculations if such an instruction is found, and notifying the user of this if verbose is set to true.\n\nNote that this function only really makes sense for x86/x64 binaries.  Don't run this on armv7l, aarch64, ppc64le etc... binaries and expect it to work.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.audit","page":"引用","title":"BinaryBuilder.Auditor.audit","text":"audit(prefix::Prefix, src_name::AbstractString = \"\";\n                      io=stderr,\n                      platform::AbstractPlatform = HostPlatform(),\n                      verbose::Bool = false,\n                      silent::Bool = false,\n                      autofix::Bool = false,\n                      has_csl::Bool = true,\n                      require_license::Bool = true,\n      )\n\nAudits a prefix to attempt to find deployability issues with the binary objects that have been installed within.  This auditing will check for relocatability issues such as dependencies on libraries outside of the current prefix, usage of advanced instruction sets such as AVX2 that may not be usable on many platforms, linkage against newer glibc symbols, etc...\n\nThis method is still a work in progress, only some of the above list is actually implemented, be sure to actually inspect Auditor.jl to see what is and is not currently in the realm of fantasy.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.Auditor.check_license","page":"引用","title":"BinaryBuilder.Auditor.check_license","text":"check_license(prefix, src_name; verbose::Bool = false,, silent::Bool = false)\n\nCheck that there are license files for the project called src_name in the prefix.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.Auditor.collapse_symlinks-Tuple{Vector{String}}","page":"引用","title":"BinaryBuilder.Auditor.collapse_symlinks","text":"collapse_symlinks(files::Vector{String})\n\nGiven a list of files, prune those that are symlinks pointing to other files within the list.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.collect_files","page":"引用","title":"BinaryBuilder.Auditor.collect_files","text":"collect_files(path::AbstractString, predicate::Function = f -> true)\n\nFind all files that satisfy predicate() when the full path to that file is passed in, returning the list of file paths.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.Auditor.compatible_marchs-Tuple{AbstractPlatform}","page":"引用","title":"BinaryBuilder.Auditor.compatible_marchs","text":"compatible_marchs(p::AbstractPlatform)\n\nReturn a (sorted) list of compatible microarchitectures, starting from the most compatible to the most highly specialized.  If no microarchitecture is specified within p, returns the most generic microarchitecture possible for the given architecture.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.detect_libgfortran_version-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}","page":"引用","title":"BinaryBuilder.Auditor.detect_libgfortran_version","text":"detect_libgfortran_version(oh::ObjectHandle, platform::AbstractPlatform)\n\nGiven an ObjectFile, examine its dynamic linkage to discover which (if any) libgfortran it's linked against.  The major SOVERSION will determine which GCC version we're restricted to.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.instruction_mnemonics-Tuple{AbstractString, AbstractPlatform}","page":"引用","title":"BinaryBuilder.Auditor.instruction_mnemonics","text":"instruction_mnemonics(path::AbstractString, platform::AbstractPlatform)\n\nDump a binary object with objdump, returning a list of instruction mnemonics for further analysis with analyze_instruction_set().\n\nNote that this function only really makes sense for x86/x64 binaries.  Don't run this on armv7l, aarch64, ppc64le etc... binaries and expect it to work.\n\nThis function returns the list of mnemonics as well as the counts of each, binned by the mapping defined within instruction_categories.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.is_for_platform-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}","page":"引用","title":"BinaryBuilder.Auditor.is_for_platform","text":"is_for_platform(h::ObjectHandle, platform::AbstractPlatform)\n\nReturns true if the given ObjectHandle refers to an object of the given platform; E.g. if the given platform is for AArch64 Linux, then h must be an ELFHandle with h.header.e_machine set to ELF.EM_AARCH64.\n\nIn particular, this method and platform_for_object() both exist because the latter is not smart enough to deal with :glibc and :musl yet.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.is_troublesome_library_link-Tuple{AbstractString, AbstractPlatform}","page":"引用","title":"BinaryBuilder.Auditor.is_troublesome_library_link","text":"is_troublesome_library_link(libname::AbstractString, platform::AbstractPlatform)\n\nReturn true if depending on libname is known to cause problems at runtime, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.minimum_march-Tuple{Dict, AbstractPlatform}","page":"引用","title":"BinaryBuilder.Auditor.minimum_march","text":"minimum_march(counts::Dict, p::AbstractPlatform)\n\nThis function returns the minimum instruction set required, depending on whether the object file being pointed to is a 32-bit or 64-bit one:\n\nFor 32-bit object files, this returns one of [\"i686\", \"prescott\"]\nFor 64-bit object files, this returns one of [\"x86_64\", \"avx\", \"avx2\", \"avx512\"]\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.platform_for_object-Tuple{ObjectFile.ObjectHandle}","page":"引用","title":"BinaryBuilder.Auditor.platform_for_object","text":"platform_for_object(oh::ObjectHandle)\n\nReturns the platform the given ObjectHandle should run on.  E.g. if the given ObjectHandle is an x86_64 Linux ELF object, this function will return Platform(\"x86_64\", \"linux\").  This function does not yet distinguish between different libc's such as :glibc and :musl.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.symlink_soname_lib-Tuple{AbstractString}","page":"引用","title":"BinaryBuilder.Auditor.symlink_soname_lib","text":"symlink_soname_lib(path::AbstractString)\n\nWe require that all shared libraries are accessible on disk through their SONAME (if it exists).  While this is almost always true in practice, it doesn't hurt to make doubly sure.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.translate_symlinks-Tuple{AbstractString}","page":"引用","title":"BinaryBuilder.Auditor.translate_symlinks","text":"translate_symlinks(root::AbstractString; verbose::Bool=false)\n\nWalks through the root directory given within root, finding all symlinks that point to an absolute path within root, and rewriting them to be a relative symlink instead, increasing relocatability.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.update_linkage-Tuple{Prefix, AbstractPlatform, AbstractString, Any, Any}","page":"引用","title":"BinaryBuilder.Auditor.update_linkage","text":"update_linkage(prefix::Prefix, platform::AbstractPlatform, path::AbstractString,\n               old_libpath, new_libpath; verbose::Bool = false)\n\nGiven a binary object located at path within prefix, update its dynamic linkage to point to new_libpath instead of old_libpath.  This is done using a tool within the cross-compilation environment such as install_name_tool on MacOS or patchelf on Linux.  Windows platforms are completely skipped, as they do not encode paths or RPaths within their executables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.warn_deadlinks-Tuple{AbstractString}","page":"引用","title":"BinaryBuilder.Auditor.warn_deadlinks","text":"warn_deadlinks(root::AbstractString)\n\nWalks through the given root directory, finding broken symlinks and warning the user about them.  This is used to catch instances such as a build recipe copying a symlink that points to a dependency; by doing so, it implicitly breaks relocatability.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.canonicalize_file_url-Tuple{Any}","page":"引用","title":"BinaryBuilder.Wizard.canonicalize_file_url","text":"Canonicalize URL to a file within a GitHub repo\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.canonicalize_source_url-Tuple{Any}","page":"引用","title":"BinaryBuilder.Wizard.canonicalize_source_url","text":"Canonicalize a GitHub repository URL\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.change_script!-Tuple{Any, Any}","page":"引用","title":"BinaryBuilder.Wizard.change_script!","text":"Change the script. This will invalidate all platforms to make sure we later\nverify that they still build with the new script.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.download_source-Tuple{BinaryBuilder.Wizard.WizardState}","page":"引用","title":"BinaryBuilder.Wizard.download_source","text":"download_source(state::WizardState)\n\nAsk the user where the source code is coming from, then download and record the relevant parameters, returning the source url, the local path it is stored at after download, and a hash identifying the version of the code. In the case of a git source URL, the hash will be a git treeish identifying the exact commit used to build the code, in the case of a tarball, it is the sha256 hash of the tarball itself.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.edit_script-Tuple{BinaryBuilder.Wizard.WizardState, AbstractString}","page":"引用","title":"BinaryBuilder.Wizard.edit_script","text":"edit_script(state::WizardState, script::AbstractString)\n\nFor consistency (and security), use the sandbox for editing a script, launching vi within an interactive session to edit a buildscript.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.filter_object_files-Tuple{Any}","page":"引用","title":"BinaryBuilder.Wizard.filter_object_files","text":"filter_object_files(files)\n\nGiven a list of files, filter out any that cannot be opened by readmeta() from ObjectFile.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.interactive_build-Tuple{BinaryBuilder.Wizard.WizardState, Prefix, Runner, AbstractString, AbstractPlatform}","page":"引用","title":"BinaryBuilder.Wizard.interactive_build","text":"interactive_build(state::WizardState, prefix::Prefix,\n                  ur::Runner, build_path::AbstractString)\n\nRuns the interactive shell for building, then captures bash history to save\nreproducible steps for building this source. Shared between steps 3 and 5\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.match_files-Tuple{BinaryBuilder.Wizard.WizardState, Prefix, AbstractPlatform, Vector}","page":"引用","title":"BinaryBuilder.Wizard.match_files","text":"match_files(state::WizardState, prefix::Prefix,\n            platform::AbstractPlatform, files::Vector; silent::Bool = false)\n\nInspects all binary files within a prefix, matching them with a given list of files, complaining if there are any files that are not properly matched and returning the set of normalized names that were not matched, or an empty set if all names were properly matched.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.normalize_name-Tuple{AbstractString}","page":"引用","title":"BinaryBuilder.Wizard.normalize_name","text":"normalize_name(file::AbstractString)\n\nGiven a filename, normalize it, stripping out extensions.  E.g. the file path \"foo/libfoo.tar.gz\" would get mapped to \"libfoo\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.pick_preferred_platform-Tuple{Any}","page":"引用","title":"BinaryBuilder.Wizard.pick_preferred_platform","text":"Pick the first platform for use to run on. We prefer Linux x86_64 because that's generally the host platform, so it's usually easiest. After that we go by the following preferences:\n\nOS (in order): Linux, Windows, OSX\nArchitecture: x86_64, i686, aarch64, powerpc64le, armv7l\nThe first remaining after this selection\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.print_autoconf_hint-Tuple{BinaryBuilder.Wizard.WizardState}","page":"引用","title":"BinaryBuilder.Wizard.print_autoconf_hint","text":"print_autoconf_hint(state::WizardState)\n\nPrint a hint for projects that use autoconf to have a good ./configure line.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.provide_hints-Tuple{BinaryBuilder.Wizard.WizardState, AbstractString}","page":"引用","title":"BinaryBuilder.Wizard.provide_hints","text":"provide_hints(state::WizardState, path::AbstractString)\n\nGiven an unpacked source directory, provide hints on how a user might go about building the binary bounty they so richly desire.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.step1-Tuple{BinaryBuilder.Wizard.WizardState}","page":"引用","title":"BinaryBuilder.Wizard.step1","text":"step1(state::WizardState)\n\nIt all starts with a single step, the unabashed ambition to leave your current stability and engage with the universe on a quest to create something new, beautiful and unforeseen.  It all ends with compiler errors.\n\nThis step selects the relevant platform(s) for the built binaries.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.step2-Tuple{BinaryBuilder.Wizard.WizardState}","page":"引用","title":"BinaryBuilder.Wizard.step2","text":"step2(state::WizardState)\n\nThis step obtains the source code to be built and required binary dependencies.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.step34-Tuple{BinaryBuilder.Wizard.WizardState}","page":"引用","title":"BinaryBuilder.Wizard.step34","text":"step34(state::WizardState)\n\nStarts initial build for Linux x86_64, which is our initial test target platform.  Sources that build properly for this platform continue on to attempt builds for more complex platforms.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.step3_audit-Tuple{BinaryBuilder.Wizard.WizardState, AbstractPlatform, String}","page":"引用","title":"BinaryBuilder.Wizard.step3_audit","text":"step3_audit(state::WizardState, platform::AbstractPlatform, prefix::Prefix)\n\nAudit the prefix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.step3_interactive-Tuple{BinaryBuilder.Wizard.WizardState, Prefix, AbstractPlatform, Runner, AbstractString, Vector{String}}","page":"引用","title":"BinaryBuilder.Wizard.step3_interactive","text":"step3_interactive(state::WizardState, prefix::Prefix, platform::AbstractPlatform,\n                  ur::Runner, build_path::AbstractString)\n\nThe interactive portion of step3, moving on to either rebuild with an edited script or proceed to step 4.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.step3_retry-Tuple{BinaryBuilder.Wizard.WizardState}","page":"引用","title":"BinaryBuilder.Wizard.step3_retry","text":"step3_retry(state::WizardState)\n\nRebuilds the initial Linux x86_64 build after things like editing the script file manually, etc...\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.step4-Tuple{BinaryBuilder.Wizard.WizardState, Runner, AbstractPlatform, AbstractString, Prefix}","page":"引用","title":"BinaryBuilder.Wizard.step4","text":"step4(state::WizardState, ur::Runner, platform::AbstractPlatform,\n      build_path::AbstractString, prefix::Prefix)\n\nThe fourth step selects build products after the first build is done\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.with_gitcreds-Tuple{Any, AbstractString, AbstractString}","page":"引用","title":"BinaryBuilder.Wizard.with_gitcreds","text":"with_gitcreds(f, username::AbstractString, password::AbstractString)\n\nCalls f with an LibGit2.UserPasswordCredential object as an argument, constructed from the username and password values. with_gitcreds ensures that the credentials object gets properly shredded after it's no longer necessary. E.g.:\n\njulia with_gitcreds(user, token) do creds     LibGit2.clone(\"https://github.com/foo/bar.git\", \"bar\"; credentials=creds) end`\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.yggdrasil_build_tarballs_path-Tuple{Any}","page":"引用","title":"BinaryBuilder.Wizard.yggdrasil_build_tarballs_path","text":"yggdrasil_build_tarballs_path(name::String)\n\nReturn the relative path within an Yggdrasil clone where this project (given its name) would be stored.  This is useful for things like generating the build_tarballs.jl file and checking to see if it already exists, etc...\n\nNote that we do not allow case-ambiguities within Yggdrasil, we check for this using the utility function case_insensitive_file_exists(path).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.yggdrasil_deploy","page":"引用","title":"BinaryBuilder.Wizard.yggdrasil_deploy","text":"yggdrasil_deploy(state::WizardState)\n\nWrite out a WizardState to a build_tarballs.jl in an Yggdrasil clone, then open a pull request against Yggdrasil.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.Wizard.yn_prompt","page":"引用","title":"BinaryBuilder.Wizard.yn_prompt","text":"yn_prompt(state::WizardState, question::AbstractString, default = :y)\n\nPerform a [Y/n] or [y/N] question loop, using default to choose between the prompt styles, and looping until a proper response (e.g. \"y\", \"yes\", \"n\" or \"no\") is received.\n\n\n\n\n\n","category":"function"},{"location":"reference/#命令行","page":"引用","title":"命令行","text":"","category":"section"},{"location":"reference/","page":"引用","title":"引用","text":"build_tarballs","category":"page"},{"location":"reference/#BinaryBuilder.build_tarballs","page":"引用","title":"BinaryBuilder.build_tarballs","text":"build_tarballs(ARGS, src_name, src_version, sources, script, platforms,\n               products, dependencies; kwargs...)\n\nThis should be the top-level function called from a build_tarballs.jl file. It takes in the information baked into a build_tarballs.jl file such as the sources to download, the products to build, etc... and will automatically download, build and package the tarballs, generating a build.jl file when appropriate.\n\nGenerally, ARGS should be the top-level Julia ARGS command-line arguments object.  build_tarballs does some rudimentary parsing of the arguments. To see what it can do, you can call it with --help in the ARGS or see the Command Line section in the manual.\n\nThe kwargs are passed on to autobuild, see there for a list of supported ones. A few additional keyword arguments are accept:\n\njulia_compat can be set to a version string which is used to set the supported Julia version in the [compat] section of the Project.toml of the generated JLL package. The default value is \"1.0\".\nlazy_artifacts sets whether the artifacts should be lazy.\ninit_block may be set to a string containing Julia code; if present, this code will be inserted into the initialization path of the generated JLL package. This can for example be used to invoke an initialization API of a shared library.\naugment_platform_block may be set to a string containing Julia code; if present, this code will be inserted into the top-level of the generated JLL package. It must define a function augment_platform! that takes as a single argument, the target platform and returns the target platform, with amended tags. This augmented platform will then be used by the JLL wrapper to select the artifact. Note that this option requires the Julia compatibility julia_compat to be 1.6 or higher.\n\nnote: Note\nThe init_block and augment_platform_block keyword arguments are experimental and may be removed in a future version of this package. Please use them sparingly.\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"引用","title":"引用","text":"build_tarballs 函数能解析命令行参数，语法通过 --help 查看：","category":"page"},{"location":"reference/","page":"引用","title":"引用","text":"````@eval using BinaryBuilder, Markdown Markdown.parse(\"\"\"","category":"page"},{"location":"reference/","page":"引用","title":"引用","text":"$(BinaryBuilder.BUILD_HELP)","category":"page"},{"location":"reference/","page":"引用","title":"引用","text":"\"\"\") ```","category":"page"},{"location":"troubleshooting/#构建故障排除","page":"构建故障排除","title":"构建故障排除","text":"","category":"section"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"此页面收集了一些已知的构建错误并介绍了如何修复它们。","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"如果您有其他提示，请提交带有建议的 PR。","category":"page"},{"location":"troubleshooting/#所有平台","page":"构建故障排除","title":"所有平台","text":"","category":"section"},{"location":"troubleshooting/#常见留言","page":"构建故障排除","title":"常见留言","text":"","category":"section"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"虽然在下面您会找到一些关于在 BinaryBuilder 中构建包时发现的常见问题的提示，但请记住，如果在构建过程中出现问题，没有修复它的灵丹妙药：您需要了解问题所在。大多数时候，这是一个反复试验的问题。最好的建议是访问构建环境并仔细阅读构建系统生成的日志文件：构建系统在屏幕上打印误导性错误消息的情况并不少见，而实际问题可能完全不同（例如“不能找到库 XYZ ”，而问题是他们运行查找库 XYZ 的命令，但由于不相关的原因而失败，例如检查中使用了错误的编译器标志）。了解构建系统正在做什么也将非常有用。","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"欢迎向 Yggdrasil 提出未能成功构建的配方的 PR，或在 [JuliaLang Slack] 的“#binarybuilder”频道中寻求帮助](https://julialang.org/slack/)。有人可能会在他们有空的时候帮助你，比如志愿者提供的任何支持。","category":"page"},{"location":"troubleshooting/#如何检索正在进行的构建脚本","page":"构建故障排除","title":"如何检索正在进行的构建脚本","text":"","category":"section"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"如果基于向导的构建在第一个平台目标之后失败，向导可能偶尔会退出而无法恢复（因为唯一的恢复模式是重试失败的平台）。在这种情况下，可以使用以下步骤检索上次构建状态和正在进行的构建脚本：","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"state = BinaryBuilder.Wizard.load_wizard_state() # select 'resume'\nBinaryBuilder.Wizard.print_build_tarballs(stdout, state)","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"然后可以根据需要编辑构建脚本——例如禁用失败的平台——并直接使用 julia build_tarballs.jl --debug --verbose 重新运行（参见手动构建文档) 调试和完成无需从头开始。","category":"page"},{"location":"troubleshooting/#找不到依赖的头文件","page":"构建故障排除","title":"找不到依赖的头文件","text":"","category":"section"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"有时构建系统找不到依赖项的头文件，即使它们已正确安装。发生这种情况时，您必须指明 C/C++ 预处理器文件的位置。","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"例如，如果项目使用 Autotools，您可以设置 CPPFLAGS 环境变量：","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"export CPPFLAGS=\"-I${includedir}\"\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs}\nmake install","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"作为例子，参见 Cairo 的构建脚本。","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"相反，如果项目使用 CMake，您将需要使用不同的环境变量，因为 CMake 会忽略 CPPFLAGS。如果找不到头文件的编译器是C编译器，则需要将路径添加到 CFLAGS 变量（例如，CFLAGS=\"-I${includedir}\"），如果这是一个 C++ 版本，你必须设置 CXXFLAGS 变量（例如，CXXFLAGS=\"-I${includedir}\"）。","category":"page"},{"location":"troubleshooting/#找不到依赖库","page":"构建故障排除","title":"找不到依赖库","text":"","category":"section"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"就像在上面的部分中一样，构建系统可能无法找到依赖项的库，即使它们安装在正确的位置，即 ${libdir} 目录中。在这些情况下，您必须通过传递选项 -L${libdir} 来通知链接器库的位置。如何做到这一点的细节取决于所使用的特定构建系统。","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"对于基于 Autotools 和 CMake 的构建，您可以设置 LDFLAGS 环境变量：","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"export LDFLAGS=\"-L${libdir}\"\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs}\nmake install","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"作为例子，参见 libwebp 构建脚本（在这种情况下，只有在为 FreeBSD 构建时才需要） .","category":"page"},{"location":"troubleshooting/#旧的-Autoconf-帮助脚本","page":"构建故障排除","title":"旧的 Autoconf 帮助脚本","text":"","category":"section"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"使用 Autoconf 的软件包带有一些帮助脚本——比如 config.sub 和 config.guess —— 上游开发人员需要保持最新以便获得最新的改进。一些软件包提供了这些脚本的非常旧的副本，例如会导致不知道 Musl C 库。在这种情况下，在运行 ./configure 之后你可能会得到类似这样的错误","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"checking build system type... Invalid configuration `x86_64-linux-musl': system `musl' not recognized\nconfigure: error: /bin/sh ./config.sub x86_64-linux-musl failed","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"BinaryBuilder 环境提供实用程序 update_configure_scripts 来自动更新这些脚本，在执行 ./configure 之前调用它：","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"update_configure_scripts\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nproc}\nmake install","category":"page"},{"location":"troubleshooting/#使用旧的-GCC-版本构建一个库，该库具有使用较新的-GCC-版本构建的依赖项","page":"构建故障排除","title":"使用旧的 GCC 版本构建一个库，该库具有使用较新的 GCC 版本构建的依赖项","text":"","category":"section"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"build_tarballs 函数的关键字参数 preferred_gcc_version 允许您在需要时选择更新的编译器来构建库。纯 C 库具有良好的兼容性，因此使用较新编译器构建的库应该能够在使用较旧 GCC 版本的系统上运行而不会出现问题。但是，请记住，BinaryBuilder.jl 中的每个 GCC 版本都捆绑了特定版本的 binutils——它提供了 ld 链接器——请参阅此表。","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"ld 非常挑剔，该工具的给定版本不喜欢与被链接较新版本的库进行链接：这意味着如果您使用 GCC v6 构建库，则需要构建所有库 GCC >= v6 取决于它。如果你不这样做，你会得到这样一个神秘的错误：","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"/opt/x86_64-linux-gnu/bin/../lib/gcc/x86_64-linux-gnu/4.8.5/../../../../x86_64-linux-gnu/bin/ld: /workspace/destdir/lib/libvpx.a(vp8_cx_iface.c.o): unrecognized relocation (0x2a) in section `.text'\n/opt/x86_64-linux-gnu/bin/../lib/gcc/x86_64-linux-gnu/4.8.5/../../../../x86_64-linux-gnu/bin/ld: final link failed: Bad value","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"解决方案是至少使用依赖项使用的最大 GCC 版本构建下游库：","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"build_tarballs(ARGS, name, version, sources, script, platforms, products, dependencies; preferred_gcc_version=v\"8\")","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"例如，FFMPEG 必须使用 GCC v8 构建 因为 LibVPX 需要 GCC v8。","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"一般来说，我们会尝试使用尽可能旧的 GCC 版本（v4.8.5 是当前可用的最旧版本）来构建，以获得最大的兼容性。","category":"page"},{"location":"troubleshooting/#运行外部可执行文件","page":"构建故障排除","title":"运行外部可执行文件","text":"","category":"section"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"BinaryBuilder 提供的构建环境是 x86_64-linux-musl，它可以运行以下平台的可执行文件：x86_64-linux-musl、x86_64-linux-gnu、i686-linux-gnu `。对于所有其他平台，如果构建系统尝试运行外部可执行文件，您将收到错误消息，通常类似于","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"./foreign.exe: line 1: ELF��\n                       @@xG@8@@@@@@���@�@@����A�A����A�A���@�@: not found\n./foreign.exe: line 1: syntax error: unexpected end of file (expecting \")\")","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"这是交叉编译时最糟糕的情况之一，并且没有简单的解决方案。您必须查看构建过程以查看是否可以跳过运行可执行文件（例如，参见 Yggdrasil#351), 或者用别的东西代替。如果可执行文件是仅编译时实用程序，请尝试使用本机编译器构建它（例如，请参阅 Yggdrasil#351 中用于构建本机 mkdefs 的补丁）","category":"page"},{"location":"troubleshooting/#Musl-Linux","page":"构建故障排除","title":"Musl Linux","text":"","category":"section"},{"location":"troubleshooting/#posix_memalign-定义错误","page":"构建故障排除","title":"posix_memalign 定义错误","text":"","category":"section"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"为 Musl 平台编译有时会失败并显示错误消息","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"/opt/x86_64-linux-musl/x86_64-linux-musl/sys-root/usr/include/stdlib.h:99:5: error: from previous declaration ‘int posix_memalign(void**, size_t, size_t)’\n int posix_memalign (void **, size_t, size_t);\n     ^","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"这是由于旧版本的 GCC 中针对此 libc 的错误，请参阅 BinaryBuilder.jl#387 了解更多详细信息。","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"有两种选择可以解决此问题：","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"通过使用 build_tarballs(...; preferred_gcc_version=v\"6\") 需要 GCC 6。在某些情况下，这可能是最简单的选择。作为例子，参见 Yggdrasil#3974。\n如果使用旧版本的 GCC 对于更广泛的兼容性很重要，您可以应用 此补丁 到构建工具链。作为例子，参见 ZeroMQ 的配方。","category":"page"},{"location":"troubleshooting/#PowerPC-Linux","page":"构建故障排除","title":"PowerPC Linux","text":"","category":"section"},{"location":"troubleshooting/#未构建共享库","page":"构建故障排除","title":"未构建共享库","text":"","category":"section"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"有时候 powerpc64le-linux-gnu 的共享库编译成功后没有建好，审计失败，因为只编译了静态库。如果构建使用 Autotools，这很可能会发生，因为 configure 脚本是使用非常旧版本的 Autotools 生成的，它不知道如何为该系统构建共享库。这里的技巧是使用 autoreconf 重新生成 configure 脚本：","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"autoreconf -vi\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nproc}\nmake install","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"作为例子，参见 Giflib 的构建器。如果您需要重新生成 configure，您可能需要运行 update_configure_scripts 以使其他平台也能正常工作。","category":"page"},{"location":"troubleshooting/#FreeBSD","page":"构建故障排除","title":"FreeBSD","text":"","category":"section"},{"location":"troubleshooting/#undefined-reference-to-backtrace_symbols'","page":"构建故障排除","title":"undefined reference to `backtrace_symbols'","text":"","category":"section"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"如果因为以下错误导致编译失败","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"undefined reference to `backtrace_symbols'\nundefined reference to `backtrace'","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"那么你需要链接到 execinfo：","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"if [[ \"${target}\" == *-freebsd* ]]; then\n    export LDFLAGS=\"-lexecinfo\"\nfi\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs}\nmake install","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"例子参见 Yggdrasil#354 和 Yggdrasil#982。","category":"page"},{"location":"troubleshooting/#undefined-reference-to-environ'","page":"构建故障排除","title":"undefined reference to `environ'","text":"","category":"section"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"此问题是由 -Wl,--no-undefined 标志引起的。如果未定义的引用一起出现，删除此标志也可以解决上述回溯问题。","category":"page"},{"location":"troubleshooting/#Windows","page":"构建故障排除","title":"Windows","text":"","category":"section"},{"location":"troubleshooting/#由于未定义的符号，Libtool-拒绝构建共享库","page":"构建故障排除","title":"由于未定义的符号，Libtool 拒绝构建共享库","text":"","category":"section"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"在为 Windows 构建时，有时 libtool 会因为未定义的符号而拒绝构建共享库。发生这种情况时，编译成功但 BinaryBuilder 的审计无法找到预期的 LibraryProduct。","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"在编译日志中，您通常可以找到类似的消息","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"libtool: warning: undefined symbols not allowed in i686-w64-mingw32 shared libraries; building static only","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"或者","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"libtool: error: can't build i686-w64-mingw32 shared library unless -no-undefined is specified","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"在这些情况下，您必须将 -no-undefined 选项传递给链接器，如第二条消息明确建议的那样。","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"正确的修复需要将 -no-undefined 标志添加到 Makefile.am 文件中相应 libtool 存档的 LDFLAGS。作为解决方案的例子，参考 CALCEPH、ERFA 和 libsharp2。","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"修补 Makefile.am 文件的一种快速的替代方法是仅将 LDFLAGS=-no-undefined 传递给 make：","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"FLAGS=()\nif [[ \"${target}\" == *-mingw* ]]; then\n    FLAGS+=(LDFLAGS=\"-no-undefined\")\nfi\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs} \"${FLAGS[@]}\"\nmake install","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"请注意，在 ./configure 之前设置 LDFLAGS=-no-undefined 会使此操作失败，因为它会运行类似 cc -no-undefined conftest.c 的命令，这会扰乱编译器）。例子参见 Yggdrasil#170、Yggdrasil#354。","category":"page"},{"location":"troubleshooting/#Libtool-拒绝构建共享库，因为-lmingw32-不是真实文件","page":"构建故障排除","title":"Libtool 拒绝构建共享库，因为 -lmingw32 不是真实文件","text":"","category":"section"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"如果您看到类似以下的错误：","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"[14:12:52] *** Warning: linker path does not have real file for library -lmingw32.\n[14:12:52] *** I have the capability to make that library automatically link in when\n[14:12:52] *** you link to this library.  But I can only do this if you have a\n[14:12:52] *** shared version of the library, which you do not appear to have\n[14:12:52] *** because I did check the linker path looking for a file starting\n[14:12:52] *** with libmingw32 and none of the candidates passed a file format test\n[14:12:52] *** using a file magic. Last file checked: /opt/x86_64-w64-mingw32/x86_64-w64-mingw32/sys-root/lib/libmingw32.a","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"这是 autoconf 的 ACF77LIBRARYLDFLAGS（或 ACFCLIBRARYLDFLAGS）宏中的错误。已提交补丁以修复此上游。","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"同时，您可以删除这些宏。它们通常不是必需的。","category":"page"},{"location":"troubleshooting/#苹果系统","page":"构建故障排除","title":"苹果系统","text":"","category":"section"},{"location":"troubleshooting/#CMake-抛出-“No-known-for-CXX-compiler”","page":"构建故障排除","title":"CMake 抛出 “No known for CXX compiler”","text":"","category":"section"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"例如，错误消息如下：","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"CMake Error in CMakeLists.txt:\n  No known features for CXX compiler\n\n  \"Clang\"\n\n  version 12.0.0.","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"此问题是由于未设置 CMake 策略 CMP0025 引起的。该策略仅影响 AppleClang 的 CompilerId，但它还有关闭上游 clang 的特征检测的效果（这是我们正在使用的）作用在 CMake 3.18 之前的 CMake 版本。在项目定义之前（或获取 CMake 的更新版本），将","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"cmake_policy(SET CMP0025 NEW)","category":"page"},{"location":"troubleshooting/","page":"构建故障排除","title":"构建故障排除","text":"添加在 CMakeLists.txt 的最顶部。","category":"page"},{"location":"building/#构建包","page":"构建包","title":"构建包","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"BinaryBuilder.jl 的构建脚本通常为 build_tarballs.jl 文件，示例如下：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"using BinaryBuilder\n\nname = \"libfoo\"\nversion = v\"1.0.1\"\nsources = [\n    ArchiveSource(\"<url to source tarball>\", \"sha256 hash\"),\n]\n\nscript = raw\"\"\"\ncd ${WORKSPACE}/srcdir/libfoo-*\nmake -j${nproc}\nmake install\n\"\"\"\n\nplatforms = supported_platforms()\n\nproducts = [\n    LibraryProduct(\"libfoo\", :libfoo),\n    ExecutableProduct(\"fooifier\", :fooifier),\n]\n\ndependencies = [\n    Dependency(\"Zlib_jll\"),\n]\n\nbuild_tarballs(ARGS, name, version, sources, script, platforms, products, dependencies)","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"build_tarballs 函数接受前边定义的变量并运行构建，将输出压缩包放入 ./products 目录，并可选择生成和发布 JLL 包。让我们更详细地了解构建器的成分是什么。","category":"page"},{"location":"building/#名称-name","page":"构建包","title":"名称 name","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"这是将在压缩包和 JLL 包中使用的名称。它应该是上游包的名称，而不是它提供的特定库或可执行文件的名称，即使它们可能重合。名称的大小写应与上游包的大小写匹配。请注意，该名称应该是一个有效的 Julia 标识符，因此它满足了一些要求，包括：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"不能以数字开头\n名称中不能包含空格、破折号或点，但可以使用下划线来代替","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"如果您不确定，可以使用 Base.isidentifer 来检查名称是否可以接受：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"julia> Base.isidentifier(\"valid_package_name\")\ntrue\n\njulia> Base.isidentifier(\"100-invalid package.name\")\nfalse","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"请注意，_jll 后缀会自动附加到生成的 JLL 包的名称中。","category":"page"},{"location":"building/#版本号-version","page":"构建包","title":"版本号 version","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"这是压缩包中使用的版本号，应该与上游包的版本一致。但是，请注意，版本号应该只包含主要、次要和补丁号，因此","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"julia> v\"1.2.3\"\nv\"1.2.3\"","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"是可以接受的，但是","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"julia> v\"1.2.3-alpha\"\nv\"1.2.3-alpha\"\n\njulia> v\"1.2.3+3\"\nv\"1.2.3+3\"","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"或包含三个以上级别的版本（例如，1.2.3.4）则不是。如有必要，将版本截断为补丁号。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"生成的 JLL 包将自动添加一个内部版本号，每次重新构建相同的包版本时都会增加它。","category":"page"},{"location":"building/#来源-sources","page":"构建包","title":"来源 sources","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"源是将被用于编译构建的内容，它们在构建过程中被放置在构建环境的 ${WORKSPACE}/srcdir 下。源可以是以下类型：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"ArchiveSource：压缩文件（例如，tar.gz，tar.bz2，tar.xz， zip) ，将被下载并自动解压；\nGitSource: 需要克隆的 git 存储库，将自从 check out 到制定的修订版。\nFileSource: 将从互联网下载的通用文件，无需特殊处理。\nDirectorySource: 一个本地目录，其内容将被复制到 ${WORKSPACE}/srcdir。这通常包含本地补丁，用于以非交互方式编辑待构建包的源代码中的文件。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"具有多个不同类型来源的包示例：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"libftd2xx。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"不要将源代码与 二进制依赖项 混淆。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"note: Note\n每个构建器都应该构建一个包：不要使用多个源将多个包捆绑到一个配方中。相反，单独构建每个包，并根据需要将它们用作二进制依赖项。这将增加包的可重用性。","category":"page"},{"location":"building/#构建脚本-script","page":"构建包","title":"构建脚本 script","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"该脚本是在构建环境中执行的 bash 脚本，构建环境使用 Musl C 库的 x86_64 Linux 环境，基于 Alpine Linux（三元组：x86_64-linux-musl）。构建提示 部分提供了有关在构建脚本中执行操作的更多详细信息。","category":"page"},{"location":"building/#平台-platforms","page":"构建包","title":"平台 platforms","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"构建器还应指定要为其构建包的平台列表。在撰写本文时，我们支持 Linux（x86_64、i686、armv6l、armv7l、aarch64、ppc64le）、Windows（x86_64、i686）、macOS（x86_64、aarch64) 和 FreeBSD (x86_64)。如果可能，我们会尝试为所有支持的平台构建，在这种情况下你可以设置","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"platforms = supported_platforms()","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"你可以使用函数 supported_platforms 和 triplet 获取受支持平台的列表及其关联的 triplets：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"using BinaryBuilder\nsupported_platforms()\ntriplet.(supported_platforms())","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"平台的三元组将用于生成压缩包的名称。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"对于某些包，（交叉）编译可能无法用于所有这些平台，或者您有兴趣仅为其中的一个子集构建包。仅为某些平台构建的包的示例包括","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"libevent;\nXorg_libX11：\n这个构建仅针对 Linux 和 FreeBSD 系统，自动从 supported_platforms 中筛出，而不明确列出平台。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"note: 译注\n注意区分目标系统与主机系统，参见 构建提示 的 目标系统与主机系统 。","category":"page"},{"location":"building/#扩展-C-字符串-ABI-或-libgfortran-版本","page":"构建包","title":"扩展 C++ 字符串 ABI 或 libgfortran 版本","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"构建库不是一项微不足道的任务，它会带来很多兼容性问题，其中一些问题在 棘手的陷阱 中有详细说明。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"特别注意这两个不兼容性问题：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"GCC 附带的标准 C++ 库对于 std::string 可以用 两个不兼容的 ABIs 之一，一个旧的通常被称为 C++03 字符串 ABI，一个新的则符合 2011 C++ 标准。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"note: Note\n此 ABI 不 与源代码使用的 C++ 标准有关，事实上，你可以使用 C++11 std::string ABI 和 C++03 std::string ABI 的 C++11 库来构建 C++03 库。这是通过适当设置 _GLIBCXX_USE_CXX11_ABI 宏来实现的。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"这意味着当使用 GCC 构建 C++ 库或公开 std::string ABI 的程序时，您必须确保用户将运行与他们的 std::string ABI 匹配的二进制文件。您可以在平台的 compiler_abi 部分手动指定 std::string ABI，但 BinaryBuilder 允许您自动扩展平台列表以包含 C++03 std::string 的条目 ABI 和另一个用于 C++11 std::string ABI 的 ABI，使用 expand_cxxstring_abis 函数：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"julia> using BinaryBuilder\n\njulia> platforms = [Platform(\"x86_64\", \"linux\")]\n1-element Vector{Platform}:\n  Linux x86_64 {libc=glibc}\n\njulia> expand_cxxstring_abis(platforms)\n2-element Vector{Platform}:\n  Linux x86_64 {cxxstring_abi=cxx03, libc=glibc}\n  Linux x86_64 {cxxstring_abi=cxx11, libc=glibc}","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"处理 C++ std::string ABI 的包示例是：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"GEOS：为所有支持的平台扩展 C++ std::string ABI； \nBloaty：仅为某些平台构建包并扩展 C++ std::string ABI；\nlibcgal_julia：仅针对带有 C++11 std::string 的平台构建 ABI。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"GCC 自带的 libgfortran 改变了 ABI 6.X -> 7.X 和 7.X -> 8.X 转换中的向后不兼容方式。这意味着当您构建将链接到 libgfortran 的包时，您必须确保用户将使用链接到与他们自己兼容的 libgfortran 版本的包。同样在这种情况下，您可以在平台的 compiler_abi 部分手动指定 libgfortran 版本，或者使用函数 expand_gfortran_versions 自动扩展平台列表以包括所有可能的 libgfortran 版本：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"julia> using BinaryBuilder\n\njulia> platforms = [Platform(\"x86_64\", \"linux\")]\n1-element Vector{Platform}:\n  Linux x86_64 {libc=glibc}\n\njulia> expand_gfortran_versions(platforms)\n3-element Vector{Platform}:\n  Linux x86_64 {libc=glibc, libgfortran_version=3.0.0}\n  Linux x86_64 {libc=glibc, libgfortran_version=4.0.0}\n  Linux x86_64 {libc=glibc, libgfortran_version=5.0.0}","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"扩展 libgfortran 版本的包示例是：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"OpenSpecFun：为所有支持的平台扩展了 libgfortran 版本；\nLibAMVW：仅为某些平台构建包并扩展 libgfortran 版本.","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"请注意，您是否需要为不同的 C++ 字符串 ABI 或 libgfortran 版本构建完全取决于当前构建的产品是通过公开 std::string ABI 还是直接链接到 libgfortran。事实上，某些依赖项需要扩展 C++ 字符串 ABI 或 libgfortran 版本，这与当前构建配方无关，BinaryBuilder 将负责安装具有匹配 ABI 的库。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"如果您不知道是否需要扩展 C++ std::string ABI 或 libgfortran 版本的平台列表，请不要担心：如果不彻底阅读源代码或实际构建包。在任何情况下，审计都会通知您是否必须使用这些 expand-* 函数。","category":"page"},{"location":"building/#独立于平台的包","page":"构建包","title":"独立于平台的包","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"BinaryBuilder.jl 对于构建涉及共享库和二进制可执行文件的包特别有用。使用此包构建独立于平台的包几乎没有什么好处，例如，在用户计算机上安装要在 Julia 包中使用的数据集。为此目的，使用 create_artifact 会做完全相同的工作。尽管如此，在某些情况下，独立于平台的 JLL 包仍然有用，例如构建一个仅包含头文件的包，这些头文件将用作其他包的依赖项。要构建独立于平台的包，您可以使用特殊平台 AnyPlatform：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"platforms = [AnyPlatform()]","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"在构建环境中，AnyPlatform 看起来像 x86_64-linux-musl，但这不会以任何方式影响您的构建。请注意，在为 AnyPlatform 构建包时，您只能拥有 FileProduct 类型的产品，因为所有其他类型都依赖于平台。为 AnyPlatform 生成的 JLL 包是 平台无关的 因此可以安装在任何机器上。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"使用 AnyPlatform 的构建器示例：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"OpenCL_Headers\nSPIRV_Headers.","category":"page"},{"location":"building/#产品","page":"构建包","title":"产品","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"产品是预期出现在生成的压缩包中的文件。如果在压缩包中找不到产品，构建将失败。产品可以是以下类型：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"LibraryProduct: 这代表一个共享库；\nExecutableProduct：这代表一个二进制可执行程序。\n注意：这不能用于解释性脚本；\nFrameworkProduct（仅在为 MacOS 构建时）：这代表一个 macOS 框架；\nFileProduct：任何类型的文件，没有特殊处理。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"审核将对构建器的产品执行一系列健全性检查，除了 FileProduct，同时尝试自动修复一些常见问题。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"您不需要将最终会出现在压缩包中的 所有 文件列为产品，而只需列出你想要确保存并且希望审计对其执行检查的文件。这通常包括共享库和二进制可执行文件。如果您还生成 JLL 包，则产品将具有一些变量，以便于引用它们。有关此的更多信息，请参阅 JLL 包 的文档。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"不同类型产品的包列表：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"Fontconfig。","category":"page"},{"location":"building/#二进制依赖","page":"构建包","title":"二进制依赖","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"构建脚本可以依赖于另一个构建器生成的二进制文件。构建器以先前构建的 JLL 包的形式指定 dependencies：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"# Dependencies of Xorg_xkbcomp\ndependencies = [\n    Dependency(\"Xorg_libxkbfile_jll\"),\n    BuildDependency(\"Xorg_util_macros_jll\"),\n]","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"Dependency 指定构建和加载所需的 JLL 包并导入到当前的构建器（最常见），目标平台的二进制文件将被安装；\nRuntimeDependency：仅在运行时需要的 JLL 包。在构建阶段，它的工件将不会被安装。\nBuildDependency 仅用于构建当前包的 JLL 包，但不加载它。该依赖项将为目标平台安装二进制文件，不会添加到生成的 JLL 包的依赖项列表中；\nHostBuildDependency: 类似于 BuildDependency，但它将为主机系统安装二进制文件。通常添加这种依赖性以提供一些二进制实用程序以在构建过程中运行。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"Dependency、RuntimeDependency、BuildDependency 和 HostBuildDependency 的参数也可以是 Pkg.PackageSpec 类型，你可以用它指定更多关于依赖的细节，比如版本号，或者非注册包。请注意，在 Yggdrasil 中，只能接受 General registry 中的 JLL 包。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"目标系统的依赖项（Dependency 和 BuildDependency ）将安装在构建环境中的 ${prefix} 下，而主机系统的依赖项（HostBuildDependency）将安装在 ${host_prefix} 下。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"在向导中，可以通过提示指定依赖项：Do you require any (binary) dependencies? [y/N]。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"依赖于其他二进制文件的构建器示例包括：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"Xorg_libX11 在构建和运行时依赖于 Xorg_libxcb_jll 和 Xorg_xtrans_jll，仅在构建时依赖于 Xorg_xorgproto_jll 和 Xorg_util_macros_jll。","category":"page"},{"location":"building/#特定于平台的依赖项","page":"构建包","title":"特定于平台的依赖项","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"默认情况下，所有依赖项都用于所有平台，但在某些情况下，包仅在某些平台上需要某些依赖项。您可以通过将 platforms 关键字参数传递给依赖构造器来指定需要依赖的平台，这是一个 AbstractPlatforms 类型的向量，指定应使用的依赖项。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"例如，假设变量 platforms 包含要为其构建包的平台的向量，您可以指定 Package_jl 在除 Windows 之外的所有平台上都是必需的","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"Dependency(\"Package_jll\"; platforms=filter(!Sys.iswindows, platforms))","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"这些平台依赖信息也被传输到 JLL 包：包装器仅在需要时加载依赖于该平台的 JLL 依赖项。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"warning: Warning\nJulia 的包管理器没有可选依赖项或平台相关依赖项的概念：这意味着当在您的环境中安装 JLL 包时，在任何情况下，它的所有依赖项都将被安装。只有在运行必要时才会加载特定于平台的依赖项。出于同样的原因，即使您指定平台不需要的依赖项，如果它也是其他一些依赖项所需的间接依赖项，构建配方仍可能会引入它。目前，BinaryBuilder.jl 在安装依赖项的工件时无法传播依赖项依赖于平台的信息。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"例子：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"ADIOS2 使用 MPICH_jll 在除 Windows 之外的所有平台上提供 MPI 实现，并为 Windows 使用 MicrosoftMPI_jll。\nGTK3 仅在 Linux 和 FreeBSD 平台上使用 X11 软件栈，仅在 Linux 上使用 Wayland。\nNativeFileDialog 仅在 Linux 和 FreeBSD 上使用 GTK3，在所有其他平台上它使用系统库，因此在这些情况下不需要其他包。","category":"page"},{"location":"building/#依赖的版本号","page":"构建包","title":"依赖的版本号","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"有两种不同的方式来指定依赖的版本，具有两种不同的含义：","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"Dependency(\"Foo_jll\", v\"1.2.3\"): Dependency 的第二个参数指定用于构建包的版本：此版本未反映在生成的 JLL 包项目中的版本兼容性边界。在这种情况下会很有用：当您要构建的包与从给定版本开始的所有依赖项版本兼容（而且您不想限制 JLL 包的兼容性范围），但为了最大化你对旧版本的兼容性能力。\nDependency(PackageSpec(; name=\"Foo_jll\", version=v\"1.2.3\")): 如果包作为 Pkg.PackageSpec 给出并且给出了 version 关键字参数，这个版本的包用于构建而且生成的 JLL 包将与提供的包版本兼容。当您的包仅与单一版本的依赖项兼容时，且希望在 JLL 包的项目中反映这种情况，应使用此选项。","category":"page"},{"location":"building/#在本地构建和测试-JLL-包","page":"构建包","title":"在本地构建和测试 JLL 包","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"作为包开发人员，您可能希望在本地测试 JLL 包，或者作为二进制依赖项开发人员，您可能希望轻松使用自定义二进制文件。通过结合 dev 中的 JLL 包和创建一个 overrides 目录，可以轻松完全控制本地 JLL 包状态。","category":"page"},{"location":"building/#覆盖预构建-JLL-包的二进制文件","page":"构建包","title":"覆盖预构建 JLL 包的二进制文件","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"运行 pkg> dev LibFoo_jll 后，本地 JLL 包将被 check out 到您 “开发中” 的目录（大多数情况的路径为 ~/.julia/dev），默认情况下，JLL 包将你的开发中的 artifacts 目录的二进制文件。如果 JLL 包目录中存在目录 override，则 JLL 包将在该 override 目录中查找二进制文件，而不是在任何 artifact 目录中。请注意，在单个 JLL 包中二进制文件不存在混合和匹配；如果存在 override 目录，则该 JLL 包中定义的所有产品都必须在 override 目录中找到，而不能来自 artifact。依赖项（例如，在另一个 JLL 包中的）可能仍会从它们各自的工件中加载，因此 JLL 依赖项本身必须是 “开发过” 的，并且具有创建了文件或符号链接的 override 目录。","category":"page"},{"location":"building/#自动填充-override-目录","page":"构建包","title":"自动填充 override 目录","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"为了简化 override 目录的创建，JLL 包包含一个 dev_jll() 函数，这将确保 ~/.julia/dev/<jll name> 包被 dev 输出，并把正常的工件内容复制到适当的 override 目录中。这对于简单地使用工件目录没有功能上的区别，但提供了一个可以由自定义构建的二进制文件替换的文件模板。","category":"page"},{"location":"building/","page":"构建包","title":"构建包","text":"请注意，此功能将在重建时推广到新的 JLL 包；如果 JLL 包没有 dev_jll() 函数，在 Yggdrasil 上打开一个问题 将生成一个新的 JLL 版本以提供功能。","category":"page"},{"location":"building/#在本地构建自定义-JLL-包","page":"构建包","title":"在本地构建自定义 JLL 包","text":"","category":"section"},{"location":"building/","page":"构建包","title":"构建包","text":"在构建新版本的 JLL 包时，如果将 --deploy 传递给 build_tarballs.jl，则新构建的 JLL 包将部署到 GitHub 存储库。（阅读 命令行 部分中的文档或通过将 --help 传递给 build_tarballs.jl 脚本来获取有关 --deploy 选项的更多信息）。如果传递 --deploy=local ，JLL 包仍将构建在 ~/.julia/dev/ 目录中，但不会上传到任何地方。这对于本地测试和验证构建的工件是否与您的包一起工作很有用。","category":"page"},{"location":"#BinaryBuilder.jl","page":"主页","title":"BinaryBuilder.jl","text":"","category":"section"},{"location":"","page":"主页","title":"主页","text":"Julia 包 BinaryBuilder.jl 的目的是提供一个编译第三方二进制依赖项的系统，该系统应可以在 Julia 发行版 中工作。特别地，通过此软件包你能够将 C、C++、Fortran、Rust、Go 等软件的大型预先存在的代码库编译成二进制文件，这些二进制文件可以在非常广泛的范围内下载和加载/运行。由于这个包支持的平台越来越多，在本地编译软件包会很困难（而且通常很昂贵），我们专注于提供一组 Linux 托管的交叉编译器。这个包将搭建一个环境来对所有主要平台进行交叉编译，并尽最大努力使编译过程尽可能轻松。","category":"page"},{"location":"","page":"主页","title":"主页","text":"注意：当前 BinaryBuilder 本身仅在 Linux x86_64 和 macOS x86_64 系统上运行，Windows 支持正在积极开发中。在 macOS 和 Windows 上，你必须安装 docker 作为后端虚拟化引擎。注意 Docker Desktop 是推荐的版本; 如果你安装了 Docker Machine，它可能无法正常工作或可能需要额外的配置。","category":"page"},{"location":"#项目流程","page":"主页","title":"项目流程","text":"","category":"section"},{"location":"","page":"主页","title":"主页","text":"假设你有一个 Julia 包 Foo.jl，它需要使用一个已编译的 libfoo 共享库。作为编写 Foo.jl 的第一步，你可以使用系统编译器在你自己的机器上本地编译 libfoo，然后使用 Libdl.dlopen() 打开库，并通过 ccall() 调用导出的函数。一旦你用 Julia 编写了你的​​ C 绑定，你自然会希望与世界其他地方分享你的劳动成果，这正是 BinaryBuilder 可以帮助你的地方。BinaryBuilder 不仅会帮助你构建所有依赖项的编译版本，还会构建一个包装器 Julia 包（称为 JLL 包）以帮助安装、版本控制和构建产品本地化。","category":"page"},{"location":"","page":"主页","title":"主页","text":"BinaryBuilder 旅程的第一步是创建一个构建配方(build recipe)，通常命名为 build_tarballs.jl。Julia 社区策划了一棵构建配方树——Yggdrasil，其已经包含了许多如何编写 build_tarballs.jl 文件的示例。这些文件包括诸如：特定构建的名称、版本和源位置等信息，以及实际执行步骤（以 bash 脚本的形式）和构建应生成的产品。","category":"page"},{"location":"","page":"主页","title":"主页","text":"成功构建的结果是一个自动生成的 JLL 包，通常上传到 github 组织JuliaBinaryWrappers。每个版本的每个构建的二进制文件都会上传到相关 JLL 包的 GitHub 发布页面。最后，会打开对 Julia 注册表 General 的合并请求，以便诸如上述 Foo.jl 之类的包可以通过简单地 pkg> add libfoo_jll 来下载二进制构件以及自动生成的 Julia 包装器代码。另请参阅 FAQ，构建提示，构建故障排除 和 棘手的陷阱 以帮助解决常见问题。","category":"page"},{"location":"#交互界面","page":"主页","title":"交互界面","text":"","category":"section"},{"location":"","page":"主页","title":"主页","text":"BinaryBuilder.jl 支持一种交互式方法，用于构建二进制依赖项并将用于构建它的命令捕获到 build_tarballs.jl 文件中：交互界面。要启动它，请运行","category":"page"},{"location":"","page":"主页","title":"主页","text":"using BinaryBuilder\nstate = BinaryBuilder.run_wizard()","category":"page"},{"location":"","page":"主页","title":"主页","text":"以及屏幕上的说明。你可以观看asciinema demo以了解使用向导向的方法。","category":"page"},{"location":"","page":"主页","title":"主页","text":"note: Note\n该向导是一个很棒的工具，特别是刚开始用 BinaryBuilder 为新包创建简单的配方。然而，它缺乏在 build_tarballs.jl 脚本中可以使用的所有选项的完全控制。要生成此文件，可以克隆 Yggdrasil，复制现有的构建配方，修改它，并提交新的拉取请求（在 构建包 中有更详细的说明）。当你想要更新现有的配方而不是从头开始使用向导时，手动编辑 build_tarballs.jl 脚本也是推荐的方法。","category":"page"},{"location":"#手动创建或编辑-build_tarballs.jl","page":"主页","title":"手动创建或编辑 build_tarballs.jl","text":"","category":"section"},{"location":"","page":"主页","title":"主页","text":"build_tarballs.jl 脚本可用作命令行实用程序，它支持若干选项以及用作目标的三元组列表。你可以在 Command Line 部分中找到有关脚本语法的更多信息，或者运行","category":"page"},{"location":"","page":"主页","title":"主页","text":"julia build_tarballs.jl --help","category":"page"},{"location":"","page":"主页","title":"主页","text":"你也可以使用下面的命令构建压缩包","category":"page"},{"location":"","page":"主页","title":"主页","text":"julia build_tarballs.jl --debug --verbose","category":"page"},{"location":"","page":"主页","title":"主页","text":"如果发生错误，--debug 选项将使你进入 BinaryBuilder 交互式 shell。如果构建失败，在找出修复构建所需的步骤之后，你必须手动更新 build_tarballs.jl 中的脚本。你应该再次运行上述命令，以确保一切都是正常的。","category":"page"},{"location":"","page":"主页","title":"主页","text":"由于 build_tarballs.jl 将 三元组 压缩包的逗号分隔列表作为参数，因此你能只选择其中的几个。例如，通过","category":"page"},{"location":"","page":"主页","title":"主页","text":"julia build_tarballs.jl --debug --verbose aarch64-linux-musl,arm-linux-musleabihf","category":"page"},{"location":"","page":"主页","title":"主页","text":"你将只为 aarch64-linux-musl 和 arm-linux-musleabihf 目标平台运行构建脚本。","category":"page"},{"location":"","page":"主页","title":"主页","text":"但是，如果你决定使用此工作流程，则需要手动提交 Yggdrasil 的拉取请求。","category":"page"},{"location":"","page":"主页","title":"主页","text":"note: 译注\n在脚本julia build_tarballs.jl --debug --verbose aarch64-linux-musl,arm-linux-musleabihf中，--verbose 后边指定目标平台的三元组列表，该列表可以通过执行using BinaryBuilder\ntriplet.(supported_platforms())来查看。此外，多个平台以 , 隔开，且不能包含空格。","category":"page"},{"location":"#GitHub-代码空间","page":"主页","title":"GitHub 代码空间","text":"","category":"section"},{"location":"","page":"主页","title":"主页","text":"如果你已经有了 GitHub Codespaces 服务的访问权限，你可以在你的浏览器或者在 Visual Studio Code 上使用 BinaryBuilder 和上述所有工作流，也包括那些不被包本身支持的操作系统！前往 Yggdrasil 并创建一个新的代码空间。","category":"page"},{"location":"#这一切是如何工作的？","page":"主页","title":"这一切是如何工作的？","text":"","category":"section"},{"location":"","page":"主页","title":"主页","text":"BinaryBuilder.jl 包装了一个经过仔细构造的 root filesystem，以便提供支持运行 Julia 的广泛平台所需的交叉编译器集。然后，这个 RootFS 用作 chroot jail 的沙盒进程，该进程在 RootFS 中运行，就仿佛它是整个世界一样。在 RootFS 中挂载包含输入源代码和（最终）输出二进制文件的工作区，并设置环境变量，以便构建工具使用特定目标平台的适当编译器。","category":"page"},{"location":"#可重复性","page":"主页","title":"可重复性","text":"","category":"section"},{"location":"","page":"主页","title":"主页","text":"可重现构建 是一组软件开发实践，指能够创建从源代码到二进制代码的独立可验证路径。","category":"page"},{"location":"","page":"主页","title":"主页","text":"BinaryBuilder.jl 实施了许多实现可重现构建所需的实践。","category":"page"},{"location":"","page":"主页","title":"主页","text":"例如，构建环境是沙盒化的，并使用固定的树结构，因此具有可重现的构建路径。","category":"page"},{"location":"","page":"主页","title":"主页","text":"BinaryBuilder.jl 使用的工具链还设置了一些环境变量 并强制执行某些有助于复现的 编译器标志。","category":"page"},{"location":"","page":"主页","title":"主页","text":"虽然 BinaryBuilder.jl 不能保证始终具有可重现的构建，但它在大多数情况下都能做到这点。","category":"page"},{"location":"","page":"主页","title":"主页","text":"BinaryBuilder.jl 中的可重复性还包括生成的压缩包：它们是使用 Tar.jl 创建的，采取了一些措施以确保具有相同 git 树哈希值的压缩包的可再现性。","category":"page"},{"location":"","page":"主页","title":"主页","text":"如果你使用相同版本的 BinaryBuilder 多次重建同一个包，生成包含主要产品的压缩包（即，不包括不可复现的日志文件）应始终具有相同的 git 树哈希和 sha256sum。构建过程结束时将打印到屏幕上并存储在 JLL 包 的 Artifacts.toml 文件中。","category":"page"},{"location":"","page":"主页","title":"主页","text":"但是有一些注意事项：","category":"page"},{"location":"","page":"主页","title":"主页","text":"只有在使用 BinaryBuilder.jl 提供的工具链时才能预期再现性；\n在 非常具体的情况 中，macOS C/C++ 工具链不会生成可重现的二进制文件。\n当进行调试构建（-g 标志）并且不单独构建具有确定名称的目标文件时，会发生这种情况。（例如，如果直接从源文件构建和链接程序或共享库，让编译器自动创建中间目标文件随机名称）。\n我们决定不处理这种情况，因为在实践中，大多数包使用的构建系统会编译具有确定名称的中间目标文件，（这也是善用 ccache 的唯一方法，在 BinaryBuilder.jl 被广泛使用）并且通常不进行调试构建，因此完全回避了这个问题。","category":"page"},{"location":"#视频和教程","page":"主页","title":"视频和教程","text":"","category":"section"},{"location":"","page":"主页","title":"主页","text":"BinaryBuilder 已经在一些视频中介绍过，如果你想了解更多关于该框架的信息，你可能需要查看它们（括号中指定了日期，以明确视频的新旧程度）：","category":"page"},{"location":"","page":"主页","title":"主页","text":"关于如何构建更好的二进制文件的 10 个技巧：Elliot Saba 在 JuliaCon 2018 的演讲介绍了早期版本的 BinaryBuilder (2018-08-09)\nBinaryBuilder.jl 简介：Mosè Giordano 的实时构建会话 (2020-04-10)\nBinaryBuilder.jl - 二进制文件的精妙艺术：Elliot Saba 和 Mosè Giordano 举办的 JuliaCon 2020 研讨会，指导用户使用 BinaryBuilder (2020-07-25)\n你与 Julia 的第一个 BinaryBuilder.jl 配方：Miguel Raz Guzmán Macedo 的实时构建 (2021-04-07)\nBinaryBuilder.jl —“正常工作”的二进制文件的精妙艺术：Elliot Saba 和 Mosè Giordano 的 AlpineConf 2021 演讲，开始时间在 4:19:00 (2021-05-15)","category":"page"},{"location":"","page":"主页","title":"主页","text":"BinaryBuilder.jl — 使用 Julia 的 Pkg 交付二进制库：Mosè Giordano 和 Elliot Saba 在 PackagingCon 2021 上的演讲 (2021-11-10)","category":"page"},{"location":"tricksy_gotchas/#棘手的陷阱","page":"棘手的陷阱","title":"棘手的陷阱","text":"","category":"section"},{"location":"tricksy_gotchas/","page":"棘手的陷阱","title":"棘手的陷阱","text":"在二进制编译和分发时，存在大量问题需进行适当处理，否则二进制文件只能在某些机器上运行。以下是 BinaryBuilder.jl 自动为您处理的事情（不完整列表）：","category":"page"},{"location":"tricksy_gotchas/","page":"棘手的陷阱","title":"棘手的陷阱","text":"统一的编译器接口","category":"page"},{"location":"tricksy_gotchas/","page":"棘手的陷阱","title":"棘手的陷阱","text":"不用担心通过奇怪的名字调用编译器；只需在适当的环境中运行 gcc，您就会得到适当的交叉编译器。三元组前缀后的名称（例如 x86_64-linux-gnu-gcc）也可以用，并且所有平台都使用相同版本的 gcc、g++ 和 gfortran。","category":"page"},{"location":"tricksy_gotchas/","page":"棘手的陷阱","title":"棘手的陷阱","text":"glibc 版本控制","category":"page"},{"location":"tricksy_gotchas/","page":"棘手的陷阱","title":"棘手的陷阱","text":"在使用 glibc 作为 C 运行库的 Linux 平台上（在撰写本文时，这是绝大多数桌面和服务器发行版的情况），有必要针对比起将要运行的 glibc 版本更 旧 的版本编译代码。例如，如果您的代码是针对 glibc v2.5 编译的，它将在 glibc v2.6 上运行，但不会在 glibc v2.4 上运行。因此，为了最大限度地提高兼容性，所有代码都应尽可能针对旧版本的 glibc 进行编译。","category":"page"},{"location":"tricksy_gotchas/","page":"棘手的陷阱","title":"棘手的陷阱","text":"gfortran 版本控制","category":"page"},{"location":"tricksy_gotchas/","page":"棘手的陷阱","title":"棘手的陷阱","text":"编译 FORTRAN 代码时，gfortran 编译器破坏了 6.X -> 7.X 转换和 7.X -> 8.X 转换中的 ABI 兼容性。这意味着使用 gfortran 6.X 构建的代码不能与使用 gfortran 7.X 构建的代码链接。因此，我们针对多个不同的 gfortran 版本编译所有 gfortran 代码，然后在运行时根据当前运行进程的已有链接决定下载哪个。","category":"page"},{"location":"tricksy_gotchas/","page":"棘手的陷阱","title":"棘手的陷阱","text":"cxx11 字符串 ABI","category":"page"},{"location":"tricksy_gotchas/","page":"棘手的陷阱","title":"棘手的陷阱","text":"在 GCC 5 中从 cxx03 标准切换到 cxx11 时，std::string 对象的内部布局发生了变化。如果 C++ 代码不是使用相同的 C++ 字符串 ABI 构建的，这会导致在公共接口上来回传递字符串的 C++ 代码之间不兼容。因此，我们检测 std::string 对象何时被传递，并警告您需要构建两个不同版本，一个是具有 cxx03 样式的字符串（通过为较新的 GCC 版本设置 -D_GLIBCXX_USE_CXX11_ABI=0 来实现），另一个是带有 cxx11 风格的字符串。","category":"page"},{"location":"tricksy_gotchas/","page":"棘手的陷阱","title":"棘手的陷阱","text":"库依赖","category":"page"},{"location":"tricksy_gotchas/","page":"棘手的陷阱","title":"棘手的陷阱","text":"二进制分发中的一大问题是不正确的库链接。在构建依赖于另一个二进制对象的二进制对象时，一些操作系统（例如 macOS）将依赖库的绝对路径加入到依赖项中，而其他操作系统依赖默认搜索路径中的库。 BinaryBuilder.jl 通过自动发现这些错误并用目标平台的 RPATH/RUNPATH 语义来修复这个问题。请注意，这在技术上是一个构建系统错误，虽然我们会自动修复它，但它会在构建前缀审核期间发出一个温和的黄色警告。","category":"page"},{"location":"tricksy_gotchas/","page":"棘手的陷阱","title":"棘手的陷阱","text":"嵌入式绝对路径","category":"page"},{"location":"tricksy_gotchas/","page":"棘手的陷阱","title":"棘手的陷阱","text":"与库依赖项类似，普通文件（甚至符号链接）可以在其中嵌入文件的绝对位置。 BinaryBuilder.jl 会自动将构建前缀目录内文件的符号链接转换为等效的相对路径，如果前缀内的任何文件包含指向构建前缀的绝对路径，则会提醒您。虽然后者不能自动修复，但它可能有助于以后跟踪软件问题。","category":"page"},{"location":"tricksy_gotchas/","page":"棘手的陷阱","title":"棘手的陷阱","text":"指令集差异","category":"page"},{"location":"tricksy_gotchas/","page":"棘手的陷阱","title":"棘手的陷阱","text":"在编译随时间发展的体系结构（例如 x86_64 ）时，确定正确的指令集为目标很重要，否则二进制文件可能包含将在编译所在计算机上运行的指令，但在没有新处理器的机器上运行出现异常错误。 BinaryBuilder.jl 将自动反汇编每个构建的二进制对象并检查所使用的指令，如果发现二进制文件不符合商定的最小指令集架构，则会警告用户。它还会注意到二进制文件是否包含 cpuid 指令，这表明二进制文件意识到此问题并将在内部切换为仅使用可用指令，是个好的迹象。","category":"page"}]
}
