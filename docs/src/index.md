
# BinaryBuilder.jl

The purpose of the [`BinaryBuilder.jl`](https://github.com/JuliaPackaging/BinaryBuilder.jl) Julia package is to provide a system for compiling 3rd-party binary dependencies that should work anywhere the [official Julia distribution](https://julialang.org/downloads) does. In particular, using this package you will be able to compile your large pre-existing codebases of C, C++, Fortran, Rust, Go, etc... software into binaries that can be downloaded and loaded/run on a very wide range of machines.  As it is difficult (and often expensive) to natively compile software packages across the growing number of platforms that this package will need to support, we focus on providing a set of Linux-hosted cross-compilers.  This package will therefore set up an environment to perform cross-compilation for all of the major platforms, and will do its best to make the compilation process as painless as possible.

Julia 包 `BinaryBuilder.jl`](https://github.com/JuliaPackaging/BinaryBuilder.jl) 的目的是提供一个系统来编译第三方二进制依赖项，该系统应该可以在官方 Julia 发行版所在的任何地方工作。特别是，使用此软件包，你将能够将 C、C++、Fortran、Rust、Go 等软件的大型预先存在的代码库编译成二进制文件，这些二进制文件可以在非常广泛的范围内下载和加载/运行机器。由于在这个软件包需要支持的越来越多的平台上本地编译软件包很困难（而且通常很昂贵），我们专注于提供一组 Linux 托管的交叉编译器。因此，这个包将搭建一个环境来对所有主要平台进行交叉编译，并尽最大努力使编译过程尽可能轻松。

Note that at this time, BinaryBuilder itself runs on Linux `x86_64` and macOS `x86_64` systems only, with Windows support under active development. On macOS and Windows, you must have `docker` installed as the backing virtualization engine.  Note that Docker Desktop is the recommended version; if you have Docker Machine installed it may not work correctly or may need additional configuration.

注意当前 BinaryBuilder 本身仅在 Linux `x86_64` 和 macOS `x86_64` 系统上运行，Windows 支持正在积极开发中。在 macOS 和 Windows 上，你必须安装 `docker` 作为后端虚拟化引擎。注意 Docker Desktop 是推荐的版本; 如果你安装了 Docker Machine，它可能无法正常工作或可能需要额外的配置。

## Project flow
## 项目流程

Suppose that you have a Julia package `Foo.jl` which wants to use a compiled `libfoo` shared library.  As your first step in writing `Foo.jl`, you may compile `libfoo` locally on your own machine with your system compiler, then using `Libdl.dlopen()` to open the library, and `ccall()` to call into the exported functions.  Once you have written your C bindings in Julia, you will naturally desire to share the fruits of your labor with the rest of the world, and this is where `BinaryBuilder` can help you.  Not only will `BinaryBuilder` aid you in constructing compiled versions of all your dependencies, but it will also build a wrapper Julia package (referred to as a [JLL package](jll.md)) to aid in installation, versioning, and build product localization.

假设你有一个 Julia 包 `Foo.jl`，它需要使用一个已编译的 `libfoo` 共享库。作为编写 `Foo.jl` 的第一步，你可以使用系统编译器在你自己的机器上本地编译 `libfoo`，然后使用 `Libdl.dlopen()` 打开库，并通过 `ccall()` 调用导出的函数。一旦你用 Julia 编写了你的​​ C 绑定，你自然会希望与世界其他地方分享你的劳动成果，这正是 `BinaryBuilder` 可以帮助你的地方。`BinaryBuilder` 不仅会帮助你构建所有依赖项的编译版本，还会构建一个包装器 Julia 包（称为 [JLL](jll.md) 包）以帮助安装、版本控制和构建产品本地化。

The first step in the `BinaryBuilder` journey is to create a build recipe, usually named `build_tarballs.jl`.  The Julia community curates a tree of build recipes, [Yggdrasil](https://github.com/JuliaPackaging/Yggdrasil), that already contains many examples of how to write a `build_tarballs.jl` file.  These files contain information such as the name, version and source locations for a particular build, as well as the actual steps (in the form of a `bash` script) and the products that should be generated by the build.

`BinaryBuilder` 旅程的第一步是创建一个构建配方(build recipe)，通常命名为 `build_tarballs.jl`。Julia 社区策划了一棵构建配方树，[Yggdrasil](https://github.com/JuliaPackaging/Yggdrasil)，其中已经包含了许多如何编写 `build_tarballs.jl` 文件的示例。这些文件包含诸如特定构建的名称、版本和源位置等信息，以及实际步骤（以 `bash` 脚本的形式）和构建应生成的产品。

The result of a successful build is an autogenerated JLL package, typically uploaded to the [JuliaBinaryWrappers](https://github.com/JuliaBinaryWrappers/) github organization.  Binaries for each version of every build are uploaded to the GitHub releases page of the relevant JLL package. Finally, a registration request is opened against the `General` Julia registry, so that packages such as the aforementioned `Foo.jl` can simply `pkg> add libfoo_jll` to download the binary artifacts as well as the autogenerated Julia wrapper code.  See also the [FAQ](FAQ.md), [build tips](build_tips.md), [build troubleshooting](troubleshooting.md) and [tricksy gotchas](tricksy_gotchas.md) for help with common problems.

成功构建的结果是一个自动生成的 JLL 包，通常上传到 github 组织[JuliaBinaryWrappers](https://github.com/JuliaBinaryWrappers/)。每个版本的每个构建的二进制文件都会上传到相关 JLL 包的 GitHub 发布页面。最后，会针对  Julia 注册表 `General` 打开注册请求，以便诸如上述 `Foo.jl` 之类的包可以通过简单地 `pkg> add libfoo_jll` 下载二进制构件以及自动生成的 Julia 包装器代码。另请参阅 [FAQ](FAQ.md)，[build tips](build_tips.md)，[build troubleshooting](troubleshooting.md) 和 [tricksy gotchas](tricksy_gotchas.md) 以帮助解决常见问题。

### Wizard interface
### Wizard 交互界面


`BinaryBuilder.jl` supports an interactive method for building the binary dependencies and capturing the commands used to build it into a `build_tarballs.jl` file: the Wizard interface.  To launch it, run

`BinaryBuilder.jl` 支持一种交互式方法，用于构建二进制依赖项并将用于构建它的命令捕获到 `build_tarballs.jl` 文件中：Wizard 交互界面。要启动它，请运行

```julia
using BinaryBuilder
state = BinaryBuilder.run_wizard()
```


and follow the instructions on-screen.  You can watch an [asciinema demo](https://asciinema.org/a/304105) of the use of the wizard.

以及屏幕上的说明。你可以观看[asciinema demo](https://asciinema.org/a/304105)以了解使用向导向的方法。


### Manually create or edit `build_tarballs.jl`

### 手动创建或编辑 `build_tarballs.jl`

The wizard is a great tool, especially to get started with BinaryBuilder and create your first simple recipes for new packages.  However, it lacks the full control of all options you can use in a `build_tarballs.jl` script.  To generate this file (explained in greater detail in [Building Packages](building.md)), one can clone `Yggdrasil`, copy an existing build recipe, modify it, and submit a new pull request.  Manually editing the `build_tarballs.jl` script is also the recommended way when you want to update an existing recipe, rather then starting from scratch with the wizard.

该向导是一个很棒的工具，特别是刚开始使用 BinaryBuilder 并为新包创建第一个简单的配方。然而，它缺乏在 `build_tarballs.jl` 脚本中可以使用的所有选项的完全控制。要生成此文件（在 [Building Packages](building.md) 中有更详细的说明），可以克隆 `Yggdrasil`，复制现有的构建配方，修改它，并提交新的拉取请求。当你想要更新现有的配方而不是从头开始使用向导时，手动编辑 `build_tarballs.jl` 脚本也是推荐的方法。

The `build_tarballs.jl` script can be used as a command line utility, it takes a few options and as argument the list of triplets of the targets.  You can find more information about the syntax of the script in the [Command Line](@ref) section or by running

`build_tarballs.jl` 脚本可以用作命令行实用程序，它采用几个选项和作为目标的三元组列表。你可以在 [Command Line](@ref) 部分中找到有关脚本语法的更多信息，或者运行

```
julia build_tarballs.jl --help
```


You can build the tarballs with

你也可以使用下面的命令构建压缩包(tarballs)

```
julia build_tarballs.jl --debug --verbose
```

The `--debug` option will drop you into the BinaryBuilder interactive shell if an error occurs.  If the build fails, after finding out the steps needed to fix the build you have to manually update the script in `build_tarballs.jl`.  You should run again the above command to make sure that everything is actually working.


如果发生错误，`--debug` 选项将使你进入 BinaryBuilder 交互式 shell。如果构建失败，在找出修复构建所需的步骤之后，你必须手动更新 `build_tarballs.jl` 中的脚本。你应该再次运行上述命令，以确保一切都是正常的。

Since `build_tarballs.jl` takes as argument the comma-separated list of [triplets](@ref Platforms) for which to build the tarballs, you can select only a few of them.  For example, with

由于 `build_tarballs.jl` 将 [三元组](@ref Platforms) 压缩包的逗号分隔列表作为参数，因此你能只选择其中的几个。例如，通过

```
julia build_tarballs.jl --debug --verbose aarch64-linux-musl,arm-linux-musleabihf
```


you'll run the build script only for the `aarch64-linux-musl` and `arm-linux-musleabihf` target platforms.

你将只为 `aarch64-linux-musl` 和 `arm-linux-musleabihf` 目标平台运行构建脚本。


If you decide to use this workflow, however, you will need to manually open pull requests for [Yggdrasil](https://github.com/JuliaPackaging/Yggdrasil/).

但是，如果你决定使用此工作流程，则需要手动提交 [Yggdrasil](https://github.com/JuliaPackaging/Yggdrasil/) 的拉取请求。

### GitHub Codespaces
### GitHub 代码空间


If you already have access to the [GitHub Codespaces](https://github.com/features/codespaces) service, you can use use BinaryBuilder and all the workflows described above in your browser or with Visual Studio Code, on any operating system, including those not natively supported by the package!  Head to [Yggdrasil](https://github.com/JuliaPackaging/Yggdrasil/) and create a new Codespace.

如果你已经有了 [GitHub Codespaces](https://github.com/features/codespaces) 服务的访问权限，你可以在你的浏览器或者使用 Visual Studio Code 上使用 BinaryBuilder 和上述所有工作流，包括那些不被包本身支持的操作系统！前往 [Yggdrasil](https://github.com/JuliaPackaging/Yggdrasil/) 并创建一个新的代码空间。


## How does this all work?
## 这一切是如何工作的？


`BinaryBuilder.jl` wraps a [root filesystem](rootfs.md) that has been carefully constructed so as to provide the set of cross-compilers needed to support the wide array of platforms that Julia runs on. This _RootFS_ is then used as the chroot jail for a sandboxed process which runs within the RootFS as if that were the whole world.  The workspace containing input source code and (eventually) output binaries is mounted within the RootFS and environment variables are setup such that the appropriate compilers for a particular target platform are used by build tools.


`BinaryBuilder.jl` 包装了一个经过仔细构造的 [root filesystem](rootfs.md)，以便提供支持 Julia 运行的广泛平台所需的交叉编译器集。然后，这个 _RootFS_ 用作 chroot jail 的沙盒进程，该进程在 RootFS 中运行，就好像它是整个世界一样。在 RootFS 中挂载包含输入源代码和（最终）输出二进制文件的工作区，并设置环境变量，以便构建工具使用特定目标平台的适当编译器。


## Reproducibility
## 可重复性

> [Reproducible builds](https://reproducible-builds.org/) are a set of software development practices that create an independently-verifiable path from source to binary code.

> [可重现构建](https://reproducible-builds.org/) 是一组软件开发实践，指能够创建从源代码到二进制代码的独立可验证路径。


`BinaryBuilder.jl` puts into place many of the practices needed to achieve reproducible builds.

`BinaryBuilder.jl` 实施了许多实现可重现构建所需的实践。


For example, the building environment is sandboxed and uses a fixed tree structure, thus having a reproducible [build path](https://reproducible-builds.org/docs/build-path/).

例如，构建环境是沙盒化的，并使用固定的树结构，因此具有可重现的[构建路径](https://reproducible-builds.org/docs/build-path/)。


The toolchain used by `BinaryBuilder.jl` also sets some [environment variables](https://reproducible-builds.org/docs/source-date-epoch/) and enforces [certain compiler flags](https://reproducible-builds.org/docs/randomness/) which help reproducibility.

`BinaryBuilder.jl` 使用的工具链还设置了一些[环境变量](https://reproducible-builds.org/docs/source-date-epoch/) 并强制执行某些有助于复现的 [编译器标志](https://reproducible-builds.org/docs/randomness/)。


While `BinaryBuilder.jl` does not guarantee to always have reproducible builds, it achieves this goal in most cases.

虽然 `BinaryBuilder.jl` 不能保证始终具有可重现的构建，但它在大多数情况下都能做到这点。


Reproducibility in `BinaryBuilder.jl` includes also the generated tarballs: they are created with [`Tar.jl`](https://github.com/JuliaIO/Tar.jl), which takes [a few measures](https://github.com/JuliaIO/Tar.jl/blob/1de4f92dc1ba4de4b54ac5279ec1d84fb15948f6/README.md#reproducibility) to ensure reproducibility of tarballs with the same git tree hash.

`BinaryBuilder.jl` 中的可重复性还包括生成的压缩包：它们是使用 [`Tar.jl`](https://github.com/JuliaIO/Tar.jl) 创建的，采取了[一些措施](https://github.com/JuliaIO/Tar.jl/blob/1de4f92dc1ba4de4b54ac5279ec1d84fb15948f6/README.md#reproducibility）以确保具有相同 git 树哈希值的压缩包的可再现性。


If you rebuild multiple times the same package, with the same version of BinaryBuilder, the generated tarball which contains the main products (i.e. not the log files which are known not to be reproducible) should always have the same git tree hash and SHA256 sum, information which are printed to screen at the end of the build process and stored in the `Artifacts.toml` file of the [JLL package](@ref JLL-packages).

如果你使用相同版本的 BinaryBuilder 多次重建同一个包，生成的包含主要产品的压缩包（即，不包括不可重现的日志文件）应该始终具有相同的 git 树哈希和 SHA256 总和，在构建过程结束时打印到屏幕上并存储在 [JLL 包](@ref JLL-packages) 的 `Artifacts.toml` 文件中的信息。


There are however some caveats:

但是有一些注意事项：


* reproducibility can only be expected when using the toolchain offered by `BinaryBuilder.jl`;

* 只有在使用 `BinaryBuilder.jl` 提供的工具链时才能预期再现性；


* there are [very specific cases](https://github.com/JuliaPackaging/BinaryBuilder.jl/issues/1230) where the macOS C/C++ toolchain does not produce reproducible binaries.

* 在 [非常具体的情况](https://github.com/JuliaPackaging/BinaryBuilder.jl/issues/1230) 中，macOS C/C++ 工具链不会生成可重现的二进制文件。


  This happens when doing debug builds (`-g` flag) _and_ not building object files with deterministic names separately (e.g. if directly building and linking a program or a shared library from the source file, letting the compiler create the intermediate object files automatically with random names).

  当进行调试构建（`-g` 标志）_并且_不单独构建具有确定名称的目标文件时，会发生这种情况。（例如，如果直接从源文件构建和链接程序或共享库，让编译器自动创建中间目标文件随机名称）。


  We have decided not to take action for this case because in practice most packages use build systems which compile intermediate object files with deterministic names (which is also the only way to take advantage of `ccache`, which `BinaryBuilder.jl` uses extensively) and typically do not do debug builds, thus sidestepping the issue entirely.

  我们决定不处理这种情况，因为在实践中，大多数包使用的构建系统会编译具有确定名称的中间目标文件，（这也是善用 `ccache` 的唯一方法，在 `BinaryBuilder.jl` 被广泛使用）并且通常不进行调试构建，因此完全回避了这个问题。

## Videos and tutorials
## 视频和教程


BinaryBuilder has been covered in some videos, you may want to check them out if you want to know more about the framework (the date is specified in parentheses, to make it clear how old/new the videos are):

BinaryBuilder 已经在一些视频中介绍过，如果你想了解更多关于该框架的信息，你可能需要查看它们（括号中指定了日期，以明确视频的新旧程度）：


* [10 tips on how to build better binaries](https://www.youtube.com/watch?v=2e0PBGSaQaI): JuliaCon 2018 talk by Elliot Saba introducing an early version of BinaryBuilder (2018-08-09)

[关于如何构建更好的二进制文件的 10 个技巧](https://www.youtube.com/watch?v=2e0PBGSaQaI)：Elliot Saba 在 JuliaCon 2018 的演讲介绍了早期版本的 BinaryBuilder (2018-08-09)


* [Introduction to BinaryBuilder.jl](https://www.youtube.com/watch?v=d_h8C4iCzno): live building session by Mosè Giordano (2020-04-10)

* [BinaryBuilder.jl 简介](https://www.youtube.com/watch?v=d_h8C4iCzno)：Mosè Giordano 的实时构建会话 (2020-04-10)


* [BinaryBuilder.jl - The Subtle Art of Binaries That Just Work](https://www.youtube.com/watch?v=3IyXsBwqll8): JuliaCon 2020 workshop by Elliot Saba and Mosè Giordano to guide users through the use of BinaryBuilder (2020-07-25)

* [BinaryBuilder.jl - 二进制文件的精妙艺术](https://www.youtube.com/watch?v=3IyXsBwqll8)：Elliot Saba 和 Mosè Giordano 举办的 JuliaCon 2020 研讨会，指导用户使用 BinaryBuilder (2020-07-25)


* [Your first BinaryBuilder.jl recipe with Julia](https://www.youtube.com/watch?v=7fkNcdbt4dg): live building by Miguel Raz Guzmán Macedo (2021-04-07)

* [你与 Julia 的第一个 BinaryBuilder.jl 配方](https://www.youtube.com/watch?v=7fkNcdbt4dg)：Miguel Raz Guzmán Macedo 的实时构建 (2021-04-07)


* [BinaryBuilder.jl — The Subtle Art of Binaries That "Just Work"](https://bbb.dereferenced.org/playback/presentation/2.3/75a49eebcb63d6fee8c55417ea7cc51768d86f3d-1621065511930): AlpineConf 2021 talk by Elliot Saba and Mosè Giordano, starts at 4:19:00 (2021-05-15)

* [BinaryBuilder.jl —“正常工作”的二进制文件的精妙艺术](https://bbb.dereferenced.org/playback/presentation/2.3/75a49eebcb63d6fee8c55417ea7cc51768d86f3d-1621065511930)：Elliot Saba 和 Mosè Giordano 的 AlpineConf 2021 演讲，开始时间在 4:19:00 (2021-05-15)


* [BinaryBuilder.jl — Using Julia's Pkg to deliver binary libraries](https://www.youtube.com/watch?v=S__x3K31qnE): PackagingCon 2021 talk by Mosè Giordano & Elliot Saba (2021-11-10)

[BinaryBuilder.jl — 使用 Julia 的 Pkg 交付二进制库](https://www.youtube.com/watch?v=S__x3K31qnE)：Mosè Giordano 和 Elliot Saba 在 PackagingCon 2021 上的演讲 (2021-11-10)

