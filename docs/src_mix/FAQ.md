
# Frequently Asked Questions

＃ 经常问的问题


### I'm having trouble compiling `<project name here>`

### 我在编译 `<project name here>` 时遇到问题


First, make sure that you can compile that project natively on whatever platform you're attempting to compile it on.  Once you are assured of that, search around the internet to see if anyone else has run into issues cross-compiling that project for that platform.  In particular, most smaller projects should be just fine, but larger projects (and especially anything that does any kind of bootstrapping) may need some extra smarts smacked into their build system to support cross-compiling.  Finally, if you're still stuck, try reaching out for help on the [`#binarybuilder` channel](https://julialang.slack.com/archives/C674ELDNX) in the JuliaLang slack.

首先，确保您可以在您尝试编译它的任何平台上本地编译该项目。一旦你确信这一点，就在互联网上搜索，看看是否有其他人在为该平台交叉编译该项目时遇到问题。特别是，大多数较小的项目应该没问题，但较大的项目（尤其是任何进行任何类型的引导的项目）可能需要在其构建系统中加入一些额外的智能以支持交叉编译。最后，如果您仍然遇到困难，请尝试通过 JuliaLang slack 中的 [`#binarybuilder` 频道](https://julialang.slack.com/archives/C674ELDNX) 寻求帮助。


### How do I use this to compile my Julia code?

### 我如何使用它来编译我的 Julia 代码？


This package does not compile Julia code; it compiles C/C++/Fortran dependencies.  Think about that time you wanted to use `IJulia` and you needed to download/install `libnettle`.  The purpose of this package is to make generated tarballs that can be downloaded/installed painlessly as possible.

这个包不编译 Julia 代码；它编译 C/C++/Fortran 依赖项。想一想你想使用 `IJulia` 并且需要下载/安装 `libnettle` 的时候。这个包的目的是使生成的 tarball 可以尽可能轻松地下载/安装。


### What is this I hear about the macOS SDK license agreement?

### 我听说的 macOS SDK 许可协议是什么？


Apple restricts distribution and usage of the macOS SDK, a necessary component to build software for macOS targets.  Please read the [Apple and Xcode SDK agreement](https://images.apple.com/legal/sla/docs/xcode.pdf) for more information on the restrictions and legal terms you agree to when using the SDK to build software for Apple operating systems. Copyright law is a complex area and you should not take legal advice from FAQs on the internet. This toolkit is designed to primarily run on Linux, though it can of course be used within a virtualized environment on a macOS machine or directly by running Linux Apple hardware. The Docker runner implements the virtualization approach on macOS machines.  `BinaryBuilder.jl`, by default, will not automatically download or use the macOS SDK on non-apple host operating systems, unless the `BINARYBUILDER_AUTOMATIC_APPLE` environment variable is set to `true`.

Apple 限制 macOS SDK 的分发和使用，这是为 macOS 目标构建软件的必要组件。请阅读[Apple 与 Xcode SDK 协议](https://images.apple.com/legal/sla/docs/xcode.pdf) 以获取更多有关使用 SDK 构建软件时您同意的限制和法律条款的信息适用于苹果操作系统。版权法是一个复杂的领域，您不应从互联网上的常见问题解答中获取法律建议。该工具包旨在主要在 Linux 上运行，但它当然可以在 macOS 机器上的虚拟化环境中使用，或者直接通过运行 Linux Apple 硬件来使用。 Docker runner 在 macOS 机器上实现虚拟化方法。默认情况下，`BinaryBuilder.jl` 不会在非苹果主机操作系统上自动下载或使用 macOS SDK，除非将 `BINARYBUILDER_AUTOMATIC_APPLE` 环境变量设置为 `true`。


### Are there other environment variables I can use?

### 我可以使用其他环境变量吗？


Yes, [take a look](environment_variables.md).

是的，[看看](environment_variables.md)。


### Hey, this is cool, can I use this for my non-Julia related project?

### 嘿，这很酷，我可以将它用于我的非 Julia 相关项目吗？


Absolutely!  There's nothing Julia-specific about the binaries generated by the cross-compilers used by `BinaryBuilder.jl`.  Although the best interface for interacting with this software will always be the Julia interface defined within this package, you are free to use these software tools for other projects as well.  Note that the cross-compiler image is built through a multistage bootstrapping process, [see this repository for more information](https://github.com/JuliaPackaging/Yggdrasil).  Further note the **macOS SDK license agreement** tidbit above.

绝对地！ `BinaryBuilder.jl` 使用的交叉编译器生成的二进制文件与 Julia 无关。尽管与此软件交互的最佳界面始终是此包中定义的 Julia 界面，但您也可以自由地将这些软件工具用于其他项目。请注意，交叉编译器映像是通过多阶段引导过程构建的，[有关详细信息，请参阅此存储库](https://github.com/JuliaPackaging/Yggdrasil)。进一步注意上面的 **macOS SDK 许可协议**花絮。


### At line XXX, ABORTED (Operation not permitted)!

### 在第 XXX 行，中止（不允许操作）！


Some linux distributions have a bug in their `overlayfs` implementation that prevents us from mounting overlay filesystems within user namespaces.  See [this Ubuntu kernel bug report](https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1531747) for a description of the situation and how Ubuntu has patched it in their kernels.  To work around this, you can launch `BinaryBuilder.jl` in "privileged container" mode.  BinaryBuilder should auto-detect this situation, however if the autodetection is not working or you want to silence the warning, you can set the `BINARYBUILDER_RUNNER` environment variable to `privileged`.  Unfortunately, this involves running `sudo` every time you launch into a BinaryBuilder session, but on the other hand, this successfully works around the issue on distributions such as Arch linux.

一些 linux 发行版在他们的 overlayfs 实现中有一个错误，阻止我们在用户命名空间中安装覆盖文件系统。请参阅[此 Ubuntu 内核错误报告](https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1531747)，了解有关情况的描述以及 Ubuntu 如何在其内核中对其进行修补。要解决此问题，您可以在“特权容器”模式下启动 `BinaryBuilder.jl`。 BinaryBuilder 应该会自动检测这种情况，但是如果自动检测不起作用或者您想消除警告，您可以将 `BINARYBUILDER_RUNNER` 环境变量设置为 `privileged`。不幸的是，这涉及在每次启动 BinaryBuilder 会话时运行 `sudo`，但另一方面，这成功地解决了 Arch linux 等发行版上的问题。


### I have to build a very small project without a Makefile, what do I have to do?

### 我必须构建一个没有 Makefile 的非常小的项目，我该怎么办？


What BinaryBuilder needs is to find the relevant file (shared libraries, or executables, etc...) organised under the `$prefix` directory: libraries should go to `${libdir}`, executables to `${bindir}`.  You may need to create those directories.  You are free to choose whether to create a simple Makefile to build the project or to do everything within the `build_tarballs.jl` script.

BinaryBuilder 需要的是找到组织在 `$prefix` 目录下的相关文件（共享库或可执行文件等...）：库应该到 `${libdir}`，可执行文件到 `${bindir}`。您可能需要创建这些目录。您可以自由选择是创建一个简单的 Makefile 来构建项目，还是在 `build_tarballs.jl` 脚本中执行所有操作。


When the script completes, BinaryBuilder expects to find at least one artifact _built for the expected architecture_ in either `${libdir}` or `${bindir}`.

当脚本完成时，BinaryBuilder 期望在 `${libdir}` 或 `${bindir}` 中找到至少一个为预期架构构建的工件。


Remember also that you should use the standard environment variables like `CC`, `CXX`, `CFLAGS`, `LDFLAGS` as appropriate in order to cross compile.  See the list of variables in the [Tips for Building Packages](build_tips.md) section.

还请记住，您应该根据需要使用标准环境变量，如 `CC`、`CXX`、`CFLAGS`、`LDFLAGS` 以便交叉编译。请参阅 [构建包的提示](build_tips.md) 部分中的变量列表。


### Can I open a shell in a particular build environment for doing some quick tests?

### 我可以在特定的构建环境中打开一个 shell 来进行一些快速测试吗？


Yes!  You can use [`BinaryBuilder.runshell(platform)`](@ref BinaryBuilderBase.runshell) to quickly start a shell in the current directory, without having to set up a working `build_tarballs.jl` script.  For example,

是的！您可以使用 [`BinaryBuilder.runshell(platform)`](@ref BinaryBuilderBase.runshell) 在当前目录中快速启动 shell，而无需设置有效的 `build_tarballs.jl` 脚本。例如，

```
julia -e 'using BinaryBuilder; BinaryBuilder.runshell(Platform("i686", "windows"))'
```


will open a shell in a Windows 32-bit build environment, without any source loaded.  The current working directory of your system will be mounted on `${WORKSPACE}` within this BinaryBuilder environment.

将在 Windows 32 位构建环境中打开一个 shell，不加载任何源代码。您系统的当前工作目录将安装在此 BinaryBuilder 环境中的“${WORKSPACE}”上。


### Can I publish a JLL package locally without going through Yggdrasil?

### 我可以在不通过 Yggdrasil 的情况下在本地发布 JLL 包吗？


You can always build a JLL package on your machine with the `--deploy` flag to the `build_tarballs.jl` script.  Read the help (`--help`) for more information.

您始终可以使用 `build_tarballs.jl` 脚本的 `--deploy` 标志在您的机器上构建一个 JLL 包。阅读帮助 (`--help`) 了解更多信息。


A common use case is that you want to build a JLL package for, say, `Libfoo`, that will be used as dependency to build `Quxlib`, and you want to make sure that building both `Libfoo` and `Quxlib` will work before submitting all the pull requests to [Yggdrasil](https://github.com/JuliaPackaging/Yggdrasil/).  You can prepare the `build_tarballs.jl` script for `Libfoo` and then build and deploy it with

一个常见的用例是，您想为 `Libfoo` 构建一个 JLL 包，它将用作构建 `Quxlib` 的依赖项，并且您想要确保同时构建 `Libfoo` 和 `Quxlib` 将在将所有拉取请求提交到 [Yggdrasil](https://github.com/JuliaPackaging/Yggdrasil/) 之前工作。您可以为 `Libfoo` 准备 `build_tarballs.jl` 脚本，然后使用

```
julia build_tarballs.jl --debug --verbose --deploy="MY_USERNAME/Libfoo_jll.jl"
```


replacing `MY_USERNAME` with your GitHub username: this will build the tarballs for all the platforms requested and upload them to a release of the `MY_USERNAME/Libfoo_jll.jl`, where the JLL package will also be created.  As explained above, you can pass argument the list of triplets of the platforms for you which you want to build the tarballs, in case you want to compile only some of them.  In the Julia REPL, you can install this package as any unregistered package with

将 `MY_USERNAME` 替换为您的 GitHub 用户名：这将为所有请求的平台构建 tarball，并将它们上传到 `MY_USERNAME/Libfoo_jll.jl` 的版本，其中也将创建 JLL 包。如上所述，如果您只想编译其中的一些，您可以将参数传递给您要构建 tarball 的平台的三元组列表。在 Julia REPL 中，您可以将此包安装为任何未注册的包

```julia
]add https://github.com/MY_USERNAME/Libfoo_jll.jl.git
```


or develop it with

或开发它

```julia
]dev https://github.com/MY_USERNAME/Libfoo_jll.jl.git
```


Since this package is unregistered, you have to use the full [`PackageSpec`](https://julialang.github.io/Pkg.jl/v1/api/#Pkg.PackageSpec) specification to add it as dependency of the local builder for `Quxlib`:

由于此包未注册，您必须使用完整的 [`PackageSpec`](https://julialang.github.io/Pkg.jl/v1/api/#Pkg.PackageSpec) 规范将其添加为本地的依赖项`Quxlib` 的构建器：

```julia
    Dependency(PackageSpec(; name = "Libfoo_jll",  uuid = "...", url = "https://github.com/MY_USERNAME/Libfoo_jll.jl.git"))
```


You can of course in turn build and deploy this package with

你当然可以反过来构建和部署这个包

```
julia build_tarballs.jl --debug --verbose --deploy="MY_USERNAME/Quxlib_jll.jl"
```


Note that `PackageSpec` can also point to a local path: e.g., `PackageSpec(; name="Libfoo_jll", uuid="...", path="/home/myname/.julia/dev/Libfoo_jll")`.  This is particularly useful when [Building a custom JLL package locally](@ref), instead of deploying it to a remote Git repository.

请注意，`PackageSpec` 也可以指向本地路径：例如，`PackageSpec(; name="Libfoo_jll", uuid="...", path="/home/myname/.julia/dev/Libfoo_jll")` .这在 [在本地构建自定义 JLL 包](@ref) 而不是将其部署到远程 Git 存储库时特别有用。


### What are those numbers in the list of sources?  How do I get them?

### 来源列表中的那些数字是什么？我如何得到它们？


The list of sources is a vector of [`BinaryBuilder.AbstractSource`](@ref)s.  What the hash is depends on what the source is:

源列表是 [`BinaryBuilder.AbstractSource`](@ref) 的向量。哈希是什么取决于来源是什么：


* For a [`FileSource`](@ref) or an [`ArchiveSource`](@ref), the hash is a 64-character SHA256 checksum.  If you have a copy of that file, you can compute the hash in Julia with

* 对于 [`FileSource`](@ref) 或 [`ArchiveSource`](@ref)，哈希值是 64 个字符的 SHA256 校验和。如果您有该文件的副本，则可以使用 Julia 计算哈希值

```julia
  using SHA
  open(path_to_the_file, "r") do f
       bytes2hex(sha256(f))
  end
  ```


  where `path_to_the_file` is a string with the path to the file.  Alternatively, you can use the command line utilities `curl` and `shasum` to compute the hash of a remote file:

其中 `path_to_the_file` 是包含文件路径的字符串。或者，您可以使用命令行实用程序“curl”和“shasum”来计算远程文件的哈希值：

```
  $ curl -L http://example.org/file.tar.gz | shasum -a 256
  ```


  replacing `http://example.org/file.tar.gz` with the actual URL of the file you want to download.

将 `http://example.org/file.tar.gz` 替换为您要下载的文件的实际 URL。


* For a [`GitSource`](@ref), the hash is the 40-character SHA1 hash of the revision you want to checkout.  For reproducibility you must indicate a specific revision, and not a branch or tag name, which are moving targets.

* 对于 [`GitSource`](@ref)，散列是您要签出的修订版的 40 个字符的 SHA1 散列。为了可重复性，您必须指出特定的修订版，而不是分支或标签名称，它们是移动目标。

