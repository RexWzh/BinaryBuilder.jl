<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>主页 · BinaryBuilder.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>BinaryBuilder.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>主页</a><ul class="internal"><li><a class="tocitem" href="#项目流程"><span>项目流程</span></a></li><li><a class="tocitem" href="#这一切是如何工作的？"><span>这一切是如何工作的？</span></a></li><li><a class="tocitem" href="#可重复性"><span>可重复性</span></a></li><li><a class="tocitem" href="#视频和教程"><span>视频和教程</span></a></li></ul></li><li><a class="tocitem" href="building/">构建包</a></li><li><a class="tocitem" href="build_tips/">构建提示</a></li><li><a class="tocitem" href="jll/">JLL 包</a></li><li><a class="tocitem" href="FAQ/">常见问题</a></li><li><a class="tocitem" href="troubleshooting/">构建故障排除</a></li><li><span class="tocitem">内部</span><ul><li><a class="tocitem" href="rootfs/">根文件系统</a></li><li><a class="tocitem" href="environment_variables/">环境变量</a></li><li><a class="tocitem" href="tricksy_gotchas/">棘手的陷阱</a></li><li><a class="tocitem" href="reference/">引用</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>主页</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>主页</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RexWzh/BinaryBuilder.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="BinaryBuilder.jl"><a class="docs-heading-anchor" href="#BinaryBuilder.jl">BinaryBuilder.jl</a><a id="BinaryBuilder.jl-1"></a><a class="docs-heading-anchor-permalink" href="#BinaryBuilder.jl" title="Permalink"></a></h1><p>Julia 包 <a href="https://github.com/JuliaPackaging/BinaryBuilder.jl"><code>BinaryBuilder.jl</code></a> 的目的是提供一个编译第三方二进制依赖项的系统，该系统应可以在 <a href="https://julialang.org/downloads">Julia 发行版</a> 中工作。特别地，通过此软件包你能够将 C、C++、Fortran、Rust、Go 等软件的大型预先存在的代码库编译成二进制文件，这些二进制文件可以在非常广泛的范围内下载和加载/运行。由于这个包支持的平台越来越多，在本地编译软件包会很困难（而且通常很昂贵），我们专注于提供一组 Linux 托管的交叉编译器。这个包将搭建一个环境来对所有主要平台进行交叉编译，并尽最大努力使编译过程尽可能轻松。</p><p>注意：当前 BinaryBuilder 本身仅在 Linux <code>x86_64</code> 和 macOS <code>x86_64</code> 系统上运行，Windows 支持正在积极开发中。在 macOS 和 Windows 上，你必须安装 <code>docker</code> 作为后端虚拟化引擎。注意 Docker Desktop 是推荐的版本; 如果你安装了 Docker Machine，它可能无法正常工作或可能需要额外的配置。</p><h2 id="项目流程"><a class="docs-heading-anchor" href="#项目流程">项目流程</a><a id="项目流程-1"></a><a class="docs-heading-anchor-permalink" href="#项目流程" title="Permalink"></a></h2><p>假设你有一个 Julia 包 <code>Foo.jl</code>，它需要使用一个已编译的 <code>libfoo</code> 共享库。作为编写 <code>Foo.jl</code> 的第一步，你可以使用系统编译器在你自己的机器上本地编译 <code>libfoo</code>，然后使用 <code>Libdl.dlopen()</code> 打开库，并通过 <code>ccall()</code> 调用导出的函数。一旦你用 Julia 编写了你的​​ C 绑定，你自然会希望与世界其他地方分享你的劳动成果，这正是 <code>BinaryBuilder</code> 可以帮助你的地方。<code>BinaryBuilder</code> 不仅会帮助你构建所有依赖项的编译版本，还会构建一个包装器 Julia 包（称为 <a href="jll/">JLL 包</a>）以帮助安装、版本控制和构建产品本地化。</p><p><code>BinaryBuilder</code> 旅程的第一步是创建一个构建配方(build recipe)，通常命名为 <code>build_tarballs.jl</code>。Julia 社区策划了一棵构建配方树——<a href="https://github.com/JuliaPackaging/Yggdrasil">Yggdrasil</a>，其已经包含了许多如何编写 <code>build_tarballs.jl</code> 文件的示例。这些文件包括诸如：特定构建的名称、版本和源位置等信息，以及实际执行步骤（以 <code>bash</code> 脚本的形式）和构建应生成的产品。</p><p>成功构建的结果是一个自动生成的 JLL 包，通常上传到 github 组织<a href="https://github.com/JuliaBinaryWrappers/">JuliaBinaryWrappers</a>。每个版本的每个构建的二进制文件都会上传到相关 JLL 包的 GitHub 发布页面。最后，会打开对 Julia 注册表 <code>General</code> 的合并请求，以便诸如上述 <code>Foo.jl</code> 之类的包可以通过简单地 <code>pkg&gt; add libfoo_jll</code> 来下载二进制构件以及自动生成的 Julia 包装器代码。另请参阅 <a href="FAQ/">FAQ</a>，<a href="build_tips/">构建提示</a>，<a href="troubleshooting/">构建故障排除</a> 和 <a href="tricksy_gotchas/">棘手的陷阱</a> 以帮助解决常见问题。</p><h3 id="交互界面"><a class="docs-heading-anchor" href="#交互界面">交互界面</a><a id="交互界面-1"></a><a class="docs-heading-anchor-permalink" href="#交互界面" title="Permalink"></a></h3><p><code>BinaryBuilder.jl</code> 支持一种交互式方法，用于构建二进制依赖项并将用于构建它的命令捕获到 <code>build_tarballs.jl</code> 文件中：交互界面。要启动它，请运行</p><pre><code class="language-julia hljs">using BinaryBuilder
state = BinaryBuilder.run_wizard()</code></pre><p>以及屏幕上的说明。你可以观看<a href="https://asciinema.org/a/304105">asciinema demo</a>以了解使用向导向的方法。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>该向导是一个很棒的工具，特别是刚开始用 BinaryBuilder 为新包创建简单的配方。然而，它缺乏在 <code>build_tarballs.jl</code> 脚本中可以使用的所有选项的完全控制。要生成此文件，可以克隆 <code>Yggdrasil</code>，复制现有的构建配方，修改它，并提交新的拉取请求（在 <a href="building/">构建包</a> 中有更详细的说明）。当你想要更新现有的配方而不是从头开始使用向导时，手动编辑 <code>build_tarballs.jl</code> 脚本也是推荐的方法。</p></div></div><h3 id="手动创建或编辑-build_tarballs.jl"><a class="docs-heading-anchor" href="#手动创建或编辑-build_tarballs.jl">手动创建或编辑 <code>build_tarballs.jl</code></a><a id="手动创建或编辑-build_tarballs.jl-1"></a><a class="docs-heading-anchor-permalink" href="#手动创建或编辑-build_tarballs.jl" title="Permalink"></a></h3><p><code>build_tarballs.jl</code> 脚本可用作命令行实用程序，它支持若干选项以及用作目标的三元组列表。你可以在 <a href="@ref">Command Line</a> 部分中找到有关脚本语法的更多信息，或者运行</p><pre><code class="nohighlight hljs">julia build_tarballs.jl --help</code></pre><p>你也可以使用下面的命令构建压缩包</p><pre><code class="nohighlight hljs">julia build_tarballs.jl --debug --verbose</code></pre><p>如果发生错误，<code>--debug</code> 选项将使你进入 BinaryBuilder 交互式 shell。如果构建失败，在找出修复构建所需的步骤之后，你必须手动更新 <code>build_tarballs.jl</code> 中的脚本。你应该再次运行上述命令，以确保一切都是正常的。</p><p>由于 <code>build_tarballs.jl</code> 将 <a href="@ref Platforms">三元组</a> 压缩包的逗号分隔列表作为参数，因此你能只选择其中的几个。例如，通过</p><pre><code class="nohighlight hljs">julia build_tarballs.jl --debug --verbose aarch64-linux-musl,arm-linux-musleabihf</code></pre><p>你将只为 <code>aarch64-linux-musl</code> 和 <code>arm-linux-musleabihf</code> 目标平台运行构建脚本。</p><p>但是，如果你决定使用此工作流程，则需要手动提交 <a href="https://github.com/JuliaPackaging/Yggdrasil/">Yggdrasil</a> 的拉取请求。</p><div class="admonition is-info"><header class="admonition-header">译注</header><div class="admonition-body"><p>在脚本</p><pre><code class="language-bash hljs">julia build_tarballs.jl --debug --verbose aarch64-linux-musl,arm-linux-musleabihf</code></pre><p>中，<code>--verbose</code> 后边指定目标平台的三元组列表，该列表可以通过执行</p><pre><code class="language-julia hljs">using BinaryBuilder
triplet.(supported_platforms())</code></pre><p>来查看。此外，多个平台以 <code>,</code> 隔开，且不能包含空格。</p></div></div><h3 id="GitHub-代码空间"><a class="docs-heading-anchor" href="#GitHub-代码空间">GitHub 代码空间</a><a id="GitHub-代码空间-1"></a><a class="docs-heading-anchor-permalink" href="#GitHub-代码空间" title="Permalink"></a></h3><p>如果你已经有了 <a href="https://github.com/features/codespaces">GitHub Codespaces</a> 服务的访问权限，你可以在你的浏览器或者在 Visual Studio Code 上使用 BinaryBuilder 和上述所有工作流，也包括那些不被包本身支持的操作系统！前往 <a href="https://github.com/JuliaPackaging/Yggdrasil/">Yggdrasil</a> 并创建一个新的代码空间。</p><h2 id="这一切是如何工作的？"><a class="docs-heading-anchor" href="#这一切是如何工作的？">这一切是如何工作的？</a><a id="这一切是如何工作的？-1"></a><a class="docs-heading-anchor-permalink" href="#这一切是如何工作的？" title="Permalink"></a></h2><p><code>BinaryBuilder.jl</code> 包装了一个经过仔细构造的 <a href="rootfs/">root filesystem</a>，以便提供支持运行 Julia 的广泛平台所需的交叉编译器集。然后，这个 <em>RootFS</em> 用作 chroot jail 的沙盒进程，该进程在 RootFS 中运行，就仿佛它是整个世界一样。在 RootFS 中挂载包含输入源代码和（最终）输出二进制文件的工作区，并设置环境变量，以便构建工具使用特定目标平台的适当编译器。</p><h2 id="可重复性"><a class="docs-heading-anchor" href="#可重复性">可重复性</a><a id="可重复性-1"></a><a class="docs-heading-anchor-permalink" href="#可重复性" title="Permalink"></a></h2><blockquote><p><a href="https://reproducible-builds.org/">可重现构建</a> 是一组软件开发实践，指能够创建从源代码到二进制代码的独立可验证路径。</p></blockquote><p><code>BinaryBuilder.jl</code> 实施了许多实现可重现构建所需的实践。</p><p>例如，构建环境是沙盒化的，并使用固定的树结构，因此具有可重现的<a href="https://reproducible-builds.org/docs/build-path/">构建路径</a>。</p><p><code>BinaryBuilder.jl</code> 使用的工具链还设置了一些<a href="https://reproducible-builds.org/docs/source-date-epoch/">环境变量</a> 并强制执行某些有助于复现的 <a href="https://reproducible-builds.org/docs/randomness/">编译器标志</a>。</p><p>虽然 <code>BinaryBuilder.jl</code> 不能保证始终具有可重现的构建，但它在大多数情况下都能做到这点。</p><p><code>BinaryBuilder.jl</code> 中的可重复性还包括生成的压缩包：它们是使用 <a href="https://github.com/JuliaIO/Tar.jl"><code>Tar.jl</code></a> 创建的，采取了<a href="https://github.com/JuliaIO/Tar.jl/blob/1de4f92dc1ba4de4b54ac5279ec1d84fb15948f6/README.md#reproducibility">一些措施</a>以确保具有相同 git 树哈希值的压缩包的可再现性。</p><p>如果你使用相同版本的 BinaryBuilder 多次重建同一个包，生成包含主要产品的压缩包（即，不包括不可复现的日志文件）应始终具有相同的 git 树哈希和 <code>sha256sum</code>。构建过程结束时将打印到屏幕上并存储在 <a href="@ref JLL-packages">JLL 包</a> 的 <code>Artifacts.toml</code> 文件中。</p><p>但是有一些注意事项：</p><ul><li><p>只有在使用 <code>BinaryBuilder.jl</code> 提供的工具链时才能预期再现性；</p></li><li><p>在 <a href="https://github.com/JuliaPackaging/BinaryBuilder.jl/issues/1230">非常具体的情况</a> 中，macOS C/C++ 工具链不会生成可重现的二进制文件。</p><p>当进行调试构建（<code>-g</code> 标志）<em>并且</em>不单独构建具有确定名称的目标文件时，会发生这种情况。（例如，如果直接从源文件构建和链接程序或共享库，让编译器自动创建中间目标文件随机名称）。</p><p>我们决定不处理这种情况，因为在实践中，大多数包使用的构建系统会编译具有确定名称的中间目标文件，（这也是善用 <code>ccache</code> 的唯一方法，在 <code>BinaryBuilder.jl</code> 被广泛使用）并且通常不进行调试构建，因此完全回避了这个问题。</p></li></ul><h2 id="视频和教程"><a class="docs-heading-anchor" href="#视频和教程">视频和教程</a><a id="视频和教程-1"></a><a class="docs-heading-anchor-permalink" href="#视频和教程" title="Permalink"></a></h2><p>BinaryBuilder 已经在一些视频中介绍过，如果你想了解更多关于该框架的信息，你可能需要查看它们（括号中指定了日期，以明确视频的新旧程度）：</p><ul><li><p><a href="https://www.youtube.com/watch?v=2e0PBGSaQaI">关于如何构建更好的二进制文件的 10 个技巧</a>：Elliot Saba 在 JuliaCon 2018 的演讲介绍了早期版本的 BinaryBuilder (2018-08-09)</p></li><li><p><a href="https://www.youtube.com/watch?v=d_h8C4iCzno">BinaryBuilder.jl 简介</a>：Mosè Giordano 的实时构建会话 (2020-04-10)</p></li><li><p><a href="https://www.youtube.com/watch?v=3IyXsBwqll8">BinaryBuilder.jl - 二进制文件的精妙艺术</a>：Elliot Saba 和 Mosè Giordano 举办的 JuliaCon 2020 研讨会，指导用户使用 BinaryBuilder (2020-07-25)</p></li><li><p><a href="https://www.youtube.com/watch?v=7fkNcdbt4dg">你与 Julia 的第一个 BinaryBuilder.jl 配方</a>：Miguel Raz Guzmán Macedo 的实时构建 (2021-04-07)</p></li><li><p><a href="https://bbb.dereferenced.org/playback/presentation/2.3/75a49eebcb63d6fee8c55417ea7cc51768d86f3d-1621065511930">BinaryBuilder.jl —“正常工作”的二进制文件的精妙艺术</a>：Elliot Saba 和 Mosè Giordano 的 AlpineConf 2021 演讲，开始时间在 4:19:00 (2021-05-15)</p></li></ul><ul><li><a href="https://www.youtube.com/watch?v=S__x3K31qnE">BinaryBuilder.jl — 使用 Julia 的 Pkg 交付二进制库</a>：Mosè Giordano 和 Elliot Saba 在 PackagingCon 2021 上的演讲 (2021-11-10)</li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="building/">构建包 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 9 February 2023 00:11">Thursday 9 February 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
