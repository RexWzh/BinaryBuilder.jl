<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>构建故障排除 · BinaryBuilder.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BinaryBuilder.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">主页</a></li><li><a class="tocitem" href="../building/">构建包</a></li><li><a class="tocitem" href="../build_tips/">构建提示</a></li><li><a class="tocitem" href="../jll/">JLL 包</a></li><li><a class="tocitem" href="../FAQ/">常见问题</a></li><li class="is-active"><a class="tocitem" href>构建故障排除</a><ul class="internal"><li><a class="tocitem" href="#所有平台"><span>所有平台</span></a></li><li><a class="tocitem" href="#Musl-Linux"><span>Musl Linux</span></a></li><li><a class="tocitem" href="#PowerPC-Linux"><span>PowerPC Linux</span></a></li><li><a class="tocitem" href="#FreeBSD"><span>FreeBSD</span></a></li><li><a class="tocitem" href="#Windows"><span>Windows</span></a></li><li><a class="tocitem" href="#苹果系统"><span>苹果系统</span></a></li></ul></li><li><span class="tocitem">内部</span><ul><li><a class="tocitem" href="../rootfs/">根文件系统</a></li><li><a class="tocitem" href="../environment_variables/">环境变量</a></li><li><a class="tocitem" href="../tricksy_gotchas/">棘手的陷阱</a></li><li><a class="tocitem" href="../reference/">引用</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>构建故障排除</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>构建故障排除</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RexWzh/BinaryBuilder.jl/blob/master/docs/src/troubleshooting.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="构建故障排除"><a class="docs-heading-anchor" href="#构建故障排除">构建故障排除</a><a id="构建故障排除-1"></a><a class="docs-heading-anchor-permalink" href="#构建故障排除" title="Permalink"></a></h1><p>此页面收集了一些已知的构建错误并介绍了如何修复它们。</p><p><em>如果您有其他提示，请提交带有建议的 PR。</em></p><h2 id="所有平台"><a class="docs-heading-anchor" href="#所有平台">所有平台</a><a id="所有平台-1"></a><a class="docs-heading-anchor-permalink" href="#所有平台" title="Permalink"></a></h2><h3 id="常见留言"><a class="docs-heading-anchor" href="#常见留言">常见留言</a><a id="常见留言-1"></a><a class="docs-heading-anchor-permalink" href="#常见留言" title="Permalink"></a></h3><p>虽然在下面您会找到一些关于在 BinaryBuilder 中构建包时发现的常见问题的提示，但请记住，如果在构建过程中出现问题，没有修复它的灵丹妙药：您需要了解问题所在。大多数时候，这是一个反复试验的问题。最好的建议是访问构建环境并仔细阅读构建系统生成的日志文件：构建系统在屏幕上打印误导性错误消息的情况并不少见，而实际问题可能完全不同（例如“不能找到库 XYZ ”，而问题是他们运行查找库 XYZ 的命令，但由于不相关的原因而失败，例如检查中使用了错误的编译器标志）。了解构建系统正在做什么也将非常有用。</p><p>欢迎向 <a href="https://github.com/JuliaPackaging/Yggdrasil/">Yggdrasil</a> 提出未能成功构建的配方的 PR，或在 [JuliaLang Slack] 的“#binarybuilder”频道中寻求帮助](https://julialang.org/slack/)。有人可能会在他们有空的时候帮助你，比如志愿者提供的任何支持。</p><h3 id="如何检索正在进行的构建脚本"><a class="docs-heading-anchor" href="#如何检索正在进行的构建脚本">如何检索正在进行的构建脚本</a><a id="如何检索正在进行的构建脚本-1"></a><a class="docs-heading-anchor-permalink" href="#如何检索正在进行的构建脚本" title="Permalink"></a></h3><p>如果基于向导的构建在第一个平台目标之后失败，向导可能偶尔会退出而无法恢复（因为唯一的恢复模式是重试失败的平台）。在这种情况下，可以使用以下步骤检索上次构建状态和正在进行的构建脚本：</p><pre><code class="nohighlight hljs">state = BinaryBuilder.Wizard.load_wizard_state() # select &#39;resume&#39;
BinaryBuilder.Wizard.print_build_tarballs(stdout, state)</code></pre><p>然后可以根据需要编辑构建脚本——例如禁用失败的平台——并直接使用 <code>julia build_tarballs.jl --debug --verbose</code> 重新运行（参见<a href="https://docs.binarybuilder.org/dev/#Manually-create-or-edit-build_tarballs.jl">手动构建文档</a>) 调试和完成<em>无需</em>从头开始。</p><h3 id="找不到依赖的头文件"><a class="docs-heading-anchor" href="#找不到依赖的头文件">找不到依赖的头文件</a><a id="找不到依赖的头文件-1"></a><a class="docs-heading-anchor-permalink" href="#找不到依赖的头文件" title="Permalink"></a></h3><p>有时构建系统找不到依赖项的头文件，即使它们已正确安装。发生这种情况时，您必须指明 C/C++ 预处理器文件的位置。</p><p>例如，如果项目使用 Autotools，您可以设置 <code>CPPFLAGS</code> 环境变量：</p><pre><code class="language-sh hljs">export CPPFLAGS=&quot;-I${includedir}&quot;
./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}
make -j${nprocs}
make install</code></pre><p>作为例子，参见 <a href="https://github.com/JuliaPackaging/Yggdrasil/blob/9a1ae803823e0dba7628bc71ff794d0c79e39c95/C/Cairo/build_tarballs.jl#L16-L17">Cairo</a> 的构建脚本。</p><p>相反，如果项目使用 CMake，您将需要使用不同的环境变量，因为 CMake 会忽略 <code>CPPFLAGS</code>。如果找不到头文件的编译器是C编译器，则需要将路径添加到 <code>CFLAGS</code> 变量（例如，<code>CFLAGS=&quot;-I${includedir}&quot;</code>），如果这是一个 C++ 版本，你必须设置 <code>CXXFLAGS</code> 变量（例如，<code>CXXFLAGS=&quot;-I${includedir}&quot;</code>）。</p><h3 id="找不到依赖库"><a class="docs-heading-anchor" href="#找不到依赖库">找不到依赖库</a><a id="找不到依赖库-1"></a><a class="docs-heading-anchor-permalink" href="#找不到依赖库" title="Permalink"></a></h3><p>就像在上面的部分中一样，构建系统可能无法找到依赖项的库，即使它们安装在正确的位置，即 <code>${libdir}</code> 目录中。在这些情况下，您必须通过传递选项 <code>-L${libdir}</code> 来通知链接器库的位置。如何做到这一点的细节取决于所使用的特定构建系统。</p><p>对于基于 Autotools 和 CMake 的构建，您可以设置 <code>LDFLAGS</code> 环境变量：</p><pre><code class="language-sh hljs">export LDFLAGS=&quot;-L${libdir}&quot;
./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}
make -j${nprocs}
make install</code></pre><p>作为例子，参见 <a href="https://github.com/JuliaPackaging/Yggdrasil/blob/dd1d1d0fbe6fee41806691e11b900961f9001a81/L/libwebp/build_tarballs.jl#L19-L21">libwebp</a> 构建脚本（在这种情况下，只有在为 FreeBSD 构建时才需要） .</p><h3 id="旧的-Autoconf-帮助脚本"><a class="docs-heading-anchor" href="#旧的-Autoconf-帮助脚本">旧的 Autoconf 帮助脚本</a><a id="旧的-Autoconf-帮助脚本-1"></a><a class="docs-heading-anchor-permalink" href="#旧的-Autoconf-帮助脚本" title="Permalink"></a></h3><p>使用 Autoconf 的软件包带有一些帮助脚本——比如 <code>config.sub</code> 和 <code>config.guess</code> —— 上游开发人员需要保持最新以便获得最新的改进。一些软件包提供了这些脚本的非常旧的副本，例如会导致不知道 Musl C 库。在这种情况下，在运行 <code>./configure</code> 之后你可能会得到类似这样的错误</p><pre><code class="nohighlight hljs">checking build system type... Invalid configuration `x86_64-linux-musl&#39;: system `musl&#39; not recognized
configure: error: /bin/sh ./config.sub x86_64-linux-musl failed</code></pre><p><code>BinaryBuilder</code> 环境提供实用程序 <a href="../build_tips/#utils_build_env"><code>update_configure_scripts</code></a> 来自动更新这些脚本，在执行 <code>./configure</code> 之前调用它：</p><pre><code class="language-sh hljs">update_configure_scripts
./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}
make -j${nproc}
make install</code></pre><h3 id="使用旧的-GCC-版本构建一个库，该库具有使用较新的-GCC-版本构建的依赖项"><a class="docs-heading-anchor" href="#使用旧的-GCC-版本构建一个库，该库具有使用较新的-GCC-版本构建的依赖项">使用旧的 GCC 版本构建一个库，该库具有使用较新的 GCC 版本构建的依赖项</a><a id="使用旧的-GCC-版本构建一个库，该库具有使用较新的-GCC-版本构建的依赖项-1"></a><a class="docs-heading-anchor-permalink" href="#使用旧的-GCC-版本构建一个库，该库具有使用较新的-GCC-版本构建的依赖项" title="Permalink"></a></h3><p><code>build_tarballs</code> 函数的关键字参数 <code>preferred_gcc_version</code> 允许您在需要时选择更新的编译器来构建库。纯 C 库具有良好的兼容性，因此使用较新编译器构建的库应该能够在使用较旧 GCC 版本的系统上运行而不会出现问题。但是，请记住，<code>BinaryBuilder.jl</code> 中的每个 GCC 版本都捆绑了特定版本的 binutils——它提供了 <code>ld</code> 链接器——请参阅<a href="https://github.com/JuliaPackaging/Yggdrasil/blob/master/RootFS.md#compiler-shards">此表</a>。</p><p><code>ld</code> 非常挑剔，该工具的给定版本不喜欢与被链接较新版本的库进行链接：这意味着如果您使用 GCC v6 构建库，则需要构建所有库 GCC &gt;= v6 取决于它。如果你不这样做，你会得到这样一个神秘的错误：</p><pre><code class="nohighlight hljs">/opt/x86_64-linux-gnu/bin/../lib/gcc/x86_64-linux-gnu/4.8.5/../../../../x86_64-linux-gnu/bin/ld: /workspace/destdir/lib/libvpx.a(vp8_cx_iface.c.o): unrecognized relocation (0x2a) in section `.text&#39;
/opt/x86_64-linux-gnu/bin/../lib/gcc/x86_64-linux-gnu/4.8.5/../../../../x86_64-linux-gnu/bin/ld: final link failed: Bad value</code></pre><p>解决方案是至少使用依赖项使用的最大 GCC 版本构建下游库：</p><pre><code class="language-julia hljs">build_tarballs(ARGS, name, version, sources, script, platforms, products, dependencies; preferred_gcc_version=v&quot;8&quot;)</code></pre><p>例如，FFMPEG <a href="https://github.com/JuliaPackaging/Yggdrasil/blob/9a1ae803823e0dba7628bc71ff794d0c79e39c95/F/FFMPEG/build_tarballs.jl#L140">必须使用 GCC v8 构建</a> 因为 LibVPX <a href="https://github.com/giordano/Yggdrasil/blob/2b13acd75081bc8105685602fcad175296264243/L/LibVPX/build_tarballs.jl">需要 GCC v8</a>。</p><p>一般来说，我们会尝试使用尽可能旧的 GCC 版本（v4.8.5 是当前可用的最旧版本）来构建，以获得最大的兼容性。</p><h3 id="运行外部可执行文件"><a class="docs-heading-anchor" href="#运行外部可执行文件">运行外部可执行文件</a><a id="运行外部可执行文件-1"></a><a class="docs-heading-anchor-permalink" href="#运行外部可执行文件" title="Permalink"></a></h3><p><code>BinaryBuilder</code> 提供的构建环境是 <code>x86_64-linux-musl</code>，它可以运行以下平台的可执行文件：<code>x86_64-linux-musl</code>、<code>x86_64-linux-gnu</code>、<code>i686-linux-gnu</code> `。对于所有其他平台，如果构建系统尝试运行外部可执行文件，您将收到错误消息，通常类似于</p><pre><code class="nohighlight hljs">./foreign.exe: line 1: ELF��
                       @@xG@8@@@@@@���@�@@����A�A����A�A���@�@: not found
./foreign.exe: line 1: syntax error: unexpected end of file (expecting &quot;)&quot;)</code></pre><p>这是交叉编译时最糟糕的情况之一，并且没有简单的解决方案。您必须查看构建过程以查看是否可以跳过运行可执行文件（例如，参见 <a href="https://github.com/JuliaPackaging/Yggdrasil/pull/351">Yggdrasil#351</a>), 或者用别的东西代替。如果可执行文件是仅编译时实用程序，请尝试使用本机编译器构建它（例如，请参阅 <a href="https://github.com/JuliaPackaging/Yggdrasil">Yggdrasil#351</a> 中用于构建本机 <code>mkdefs</code> 的补丁）</p><h2 id="Musl-Linux"><a class="docs-heading-anchor" href="#Musl-Linux">Musl Linux</a><a id="Musl-Linux-1"></a><a class="docs-heading-anchor-permalink" href="#Musl-Linux" title="Permalink"></a></h2><h3 id="posix_memalign-定义错误"><a class="docs-heading-anchor" href="#posix_memalign-定义错误"><code>posix_memalign</code> 定义错误</a><a id="posix_memalign-定义错误-1"></a><a class="docs-heading-anchor-permalink" href="#posix_memalign-定义错误" title="Permalink"></a></h3><p>为 Musl 平台编译有时会失败并显示错误消息</p><pre><code class="nohighlight hljs">/opt/x86_64-linux-musl/x86_64-linux-musl/sys-root/usr/include/stdlib.h:99:5: error: from previous declaration ‘int posix_memalign(void**, size_t, size_t)’
 int posix_memalign (void **, size_t, size_t);
     ^</code></pre><p>这是由于旧版本的 GCC 中针对此 libc 的错误，请参阅 <a href="https://github.com/JuliaPackaging/BinaryBuilder.jl/issues/387">BinaryBuilder.jl#387</a> 了解更多详细信息。</p><p>有两种选择可以解决此问题：</p><ul><li><p>通过使用 <code>build_tarballs(...; preferred_gcc_version=v&quot;6&quot;)</code> 需要 GCC 6。在某些情况下，这可能是最简单的选择。作为例子，参见 <a href="https://github.com/JuliaPackaging/Yggdrasil/pull/3974">Yggdrasil#3974</a>。</p></li><li><p>如果使用旧版本的 GCC 对于更广泛的兼容性很重要，您可以应用 <a href="https://github.com/JuliaPackaging/Yggdrasil/blob/48ac662cd53e02aff0189c81008874a04f7172c7/Z/ZeroMQ/bundled/patches/mm_malloc.patch">此补丁</a> 到构建工具链。作为例子，参见 <a href="https://github.com/JuliaPackaging/Yggdrasil/blob/48ac662cd53e02aff0189c81008874a04f7172c7/Z/ZeroMQ/build_tarballs.jl#L20-L26">ZeroMQ</a> 的配方。</p></li></ul><h2 id="PowerPC-Linux"><a class="docs-heading-anchor" href="#PowerPC-Linux">PowerPC Linux</a><a id="PowerPC-Linux-1"></a><a class="docs-heading-anchor-permalink" href="#PowerPC-Linux" title="Permalink"></a></h2><h3 id="未构建共享库"><a class="docs-heading-anchor" href="#未构建共享库">未构建共享库</a><a id="未构建共享库-1"></a><a class="docs-heading-anchor-permalink" href="#未构建共享库" title="Permalink"></a></h3><p>有时候 <code>powerpc64le-linux-gnu</code> 的共享库编译成功后没有建好，审计失败，因为只编译了静态库。如果构建使用 Autotools，这很可能会发生，因为 <code>configure</code> 脚本是使用非常旧版本的 Autotools 生成的，它不知道如何为该系统构建共享库。这里的技巧是使用 <code>autoreconf</code> 重新生成 <code>configure</code> 脚本：</p><pre><code class="language-sh hljs">autoreconf -vi
./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}
make -j${nproc}
make install</code></pre><p>作为例子，参见 <a href="https://github.com/JuliaPackaging/Yggdrasil/blob/78fb3a7b4d00f3bc7fd2b1bcd24e96d6f31d6c4b/G/Giflib/build_tarballs.jl">Giflib</a> 的构建器。如果您需要重新生成 <code>configure</code>，您可能需要运行 <a href="../build_tips/#utils_build_env"><code>update_configure_scripts</code></a> 以使其他平台也能正常工作。</p><h2 id="FreeBSD"><a class="docs-heading-anchor" href="#FreeBSD">FreeBSD</a><a id="FreeBSD-1"></a><a class="docs-heading-anchor-permalink" href="#FreeBSD" title="Permalink"></a></h2><h3 id="undefined-reference-to-backtrace_symbols&#39;"><a class="docs-heading-anchor" href="#undefined-reference-to-backtrace_symbols&#39;"><code>undefined reference to `backtrace_symbols&#39;</code></a><a id="undefined-reference-to-backtrace_symbols&#39;-1"></a><a class="docs-heading-anchor-permalink" href="#undefined-reference-to-backtrace_symbols&#39;" title="Permalink"></a></h3><p>如果因为以下错误导致编译失败</p><pre><code class="nohighlight hljs">undefined reference to `backtrace_symbols&#39;
undefined reference to `backtrace&#39;</code></pre><p>那么你需要链接到 <code>execinfo</code>：</p><pre><code class="language-sh hljs">if [[ &quot;${target}&quot; == *-freebsd* ]]; then
    export LDFLAGS=&quot;-lexecinfo&quot;
fi
./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}
make -j${nprocs}
make install</code></pre><p>例子参见 <a href="https://github.com/JuliaPackaging/Yggdrasil/pull/354">Yggdrasil#354</a> 和 <a href="https://github.com/JuliaPackaging/Yggdrasil/pull/982">Yggdrasil#982</a>。</p><h3 id="undefined-reference-to-environ&#39;"><a class="docs-heading-anchor" href="#undefined-reference-to-environ&#39;"><code>undefined reference to `environ&#39;</code></a><a id="undefined-reference-to-environ&#39;-1"></a><a class="docs-heading-anchor-permalink" href="#undefined-reference-to-environ&#39;" title="Permalink"></a></h3><p>此问题是由 <code>-Wl,--no-undefined</code> 标志引起的。如果未定义的引用一起出现，删除此标志也可以解决上述回溯问题。</p><h2 id="Windows"><a class="docs-heading-anchor" href="#Windows">Windows</a><a id="Windows-1"></a><a class="docs-heading-anchor-permalink" href="#Windows" title="Permalink"></a></h2><h3 id="由于未定义的符号，Libtool-拒绝构建共享库"><a class="docs-heading-anchor" href="#由于未定义的符号，Libtool-拒绝构建共享库">由于未定义的符号，Libtool 拒绝构建共享库</a><a id="由于未定义的符号，Libtool-拒绝构建共享库-1"></a><a class="docs-heading-anchor-permalink" href="#由于未定义的符号，Libtool-拒绝构建共享库" title="Permalink"></a></h3><p>在为 Windows 构建时，有时 libtool 会因为未定义的符号而拒绝构建共享库。发生这种情况时，编译成功但 BinaryBuilder 的审计无法找到预期的 <code>LibraryProduct</code>。</p><p>在编译日志中，您通常可以找到类似的消息</p><pre><code class="nohighlight hljs">libtool: warning: undefined symbols not allowed in i686-w64-mingw32 shared libraries; building static only</code></pre><p>或者</p><pre><code class="nohighlight hljs">libtool: error: can&#39;t build i686-w64-mingw32 shared library unless -no-undefined is specified</code></pre><p>在这些情况下，您必须将 <code>-no-undefined</code> 选项传递给链接器，如第二条消息明确建议的那样。</p><p>正确的修复需要将 <code>-no-undefined</code> 标志添加到 <code>Makefile.am</code> 文件中相应 libtool 存档的 <code>LDFLAGS</code>。作为解决方案的例子，参考 <a href="https://github.com/JuliaPackaging/Yggdrasil/blob/d1e5159beef7fcf8c631e893f62925ca5bd54bec/C/CALCEPH/build_tarballs.jl#L19"><code>CALCEPH</code></a>、<a href="https://github.com/JuliaPackaging/Yggdrasil/blob/d1e5159beef7fcf8c631e893f62925ca5bd54bec/E/ERFA/build_tarballs.jl#L17"><code>ERFA</code></a> 和 <a href="https://github.com/JuliaPackaging/Yggdrasil/blob/d1e5159beef7fcf8c631e893f62925ca5bd54bec/L/libsharp2/build_tarballs.jl#L19"><code>libsharp2</code></a>。</p><p>修补 <code>Makefile.am</code> 文件的一种快速的替代方法是仅将 <code>LDFLAGS=-no-undefined</code> 传递给 <code>make</code>：</p><pre><code class="language-sh hljs">FLAGS=()
if [[ &quot;${target}&quot; == *-mingw* ]]; then
    FLAGS+=(LDFLAGS=&quot;-no-undefined&quot;)
fi
./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}
make -j${nprocs} &quot;${FLAGS[@]}&quot;
make install</code></pre><p>请注意，在 <code>./configure</code> 之前设置 <code>LDFLAGS=-no-undefined</code> 会使此操作失败，因为它会运行类似 <code>cc -no-undefined conftest.c</code> 的命令，这会扰乱编译器）。例子参见 <a href="https://github.com/JuliaPackaging/Yggdrasil/pull/170">Yggdrasil#170</a>、<a href="https://github.com/JuliaPackaging/Yggdrasil/pull/354">Yggdrasil#354</a>。</p><h3 id="Libtool-拒绝构建共享库，因为-lmingw32-不是真实文件"><a class="docs-heading-anchor" href="#Libtool-拒绝构建共享库，因为-lmingw32-不是真实文件">Libtool 拒绝构建共享库，因为 <code>-lmingw32</code> 不是真实文件</a><a id="Libtool-拒绝构建共享库，因为-lmingw32-不是真实文件-1"></a><a class="docs-heading-anchor-permalink" href="#Libtool-拒绝构建共享库，因为-lmingw32-不是真实文件" title="Permalink"></a></h3><p>如果您看到类似以下的错误：</p><pre><code class="nohighlight hljs">[14:12:52] *** Warning: linker path does not have real file for library -lmingw32.
[14:12:52] *** I have the capability to make that library automatically link in when
[14:12:52] *** you link to this library.  But I can only do this if you have a
[14:12:52] *** shared version of the library, which you do not appear to have
[14:12:52] *** because I did check the linker path looking for a file starting
[14:12:52] *** with libmingw32 and none of the candidates passed a file format test
[14:12:52] *** using a file magic. Last file checked: /opt/x86_64-w64-mingw32/x86_64-w64-mingw32/sys-root/lib/libmingw32.a</code></pre><p>这是 autoconf 的 AC<em>F77</em>LIBRARY<em>LDFLAGS（或 AC</em>FC<em>LIBRARY</em>LDFLAGS）宏中的错误。已提交补丁以修复此上游。</p><p>同时，您可以删除这些宏。它们通常不是必需的。</p><h2 id="苹果系统"><a class="docs-heading-anchor" href="#苹果系统">苹果系统</a><a id="苹果系统-1"></a><a class="docs-heading-anchor-permalink" href="#苹果系统" title="Permalink"></a></h2><h3 id="CMake-抛出-“No-known-for-CXX-compiler”"><a class="docs-heading-anchor" href="#CMake-抛出-“No-known-for-CXX-compiler”">CMake 抛出 “No known for CXX compiler”</a><a id="CMake-抛出-“No-known-for-CXX-compiler”-1"></a><a class="docs-heading-anchor-permalink" href="#CMake-抛出-“No-known-for-CXX-compiler”" title="Permalink"></a></h3><p>例如，错误消息如下：</p><pre><code class="nohighlight hljs">CMake Error in CMakeLists.txt:
  No known features for CXX compiler

  &quot;Clang&quot;

  version 12.0.0.</code></pre><p>此问题是由于未设置 CMake 策略 CMP0025 引起的。该策略仅影响 AppleClang 的 CompilerId，但它还有关闭上游 clang 的特征检测的效果（这是我们正在使用的）作用在 CMake 3.18 之前的 CMake 版本。在项目定义之前（或获取 CMake 的更新版本），将</p><pre><code class="nohighlight hljs">cmake_policy(SET CMP0025 NEW)</code></pre><p>添加在 CMakeLists.txt 的最顶部。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../FAQ/">« 常见问题</a><a class="docs-footer-nextpage" href="../rootfs/">根文件系统 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 9 February 2023 00:11">Thursday 9 February 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
